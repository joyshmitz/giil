#!/usr/bin/env bash
#
# giil - Get iCloud Image Link (Hybrid Edition v3.0)
# Downloads images from iCloud photo shares with maximum reliability
#
# FEATURES:
#   - Primary: Click Download button (direct file acquisition)
#   - Fallback 1: Network interception (largest CDN image)
#   - Fallback 2: Element screenshot
#   - Fallback 3: Viewport screenshot
#   - EXIF datetime extraction for filenames
#   - Sharp + MozJPEG for superior compression
#   - HEIC/HEIF support with platform fallbacks
#   - Cookie/overlay auto-dismissal
#   - Album mode (--all) for downloading entire shared albums
#   - JSON output mode for scripting
#
# Usage:
#   giil <icloud-photo-url> [options]
#
# Options:
#   --base64         Output image as base64 to stdout
#   --json           Output JSON metadata instead of plain path
#   --all            Download all photos from shared album
#   --output DIR     Output directory (default: current)
#   --optimize       Apply MozJPEG optimization (opt-in compression)
#   --convert FMT    Convert to format: jpeg, png, webp
#   --quality N      JPEG/WebP quality (default: 85, with --optimize/--convert)
#   --update         Force update Playwright/dependencies
#   --debug          Save debug artifacts on failure
#   --timeout N      Page load timeout in seconds (default: 60)
#   --help           Show help message
#   --version        Show version
#

set -euo pipefail

VERSION="3.0.0"

# -----------------------------------------------------------------------------
# Exit Codes (v3.0+ extended scheme with backwards compatibility)
# -----------------------------------------------------------------------------
# BREAKING CHANGE in v3.0: Codes 4 and 5 moved to 10 and 11.
# See hdm.1.4 for migration guidance.
#
# Local/usage errors (1-3): Same as v2
# Reserved (4-9): For future local errors
# Remote/content errors (10-19): Server-side failures
# Internal errors (20+): Bugs in giil
# -----------------------------------------------------------------------------
readonly EXIT_SUCCESS=0           # Success
readonly EXIT_CAPTURE_FAILURE=1   # All capture strategies failed
readonly EXIT_USAGE_ERROR=2       # Bad CLI options or arguments
readonly EXIT_DEPENDENCY_ERROR=3  # Node.js/Playwright/Sharp missing (unchanged from v2)
readonly EXIT_NETWORK_ERROR=10    # Timeout, DNS, unreachable (was 4 in v2)
readonly EXIT_AUTH_REQUIRED=11    # Login redirect, password required (was 5 in v2)
readonly EXIT_NOT_FOUND=12        # Expired link, deleted, 404
readonly EXIT_UNSUPPORTED_TYPE=13 # Video, Google Doc, unsupported content
readonly EXIT_INTERNAL_ERROR=20   # Bug in giil (please report!)

# Colors for output (fallback when gum not available)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
DIM='\033[2m'
ITALIC='\033[3m'
NC='\033[0m'

# Gum availability flag
GUM_AVAILABLE=false

# Repository info for update checking
REPO_OWNER="Dicklesworthstone"
REPO_NAME="get_icloud_image_link"
VERSION_URL="https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/main/VERSION"

# -----------------------------------------------------------------------------
# Update checking (opt-in via GIIL_CHECK_UPDATES=1)
# -----------------------------------------------------------------------------

check_for_updates() {
    # Only check if explicitly enabled
    [[ -z "${GIIL_CHECK_UPDATES:-}" ]] && return 0

    # Only check once per day (cache result)
    # Note: GIIL_HOME is set in globals before main() is called
    local check_file="${GIIL_HOME}/.last_update_check"
    local one_day=86400

    mkdir -p "$GIIL_HOME" 2>/dev/null || true

    if [[ -f "$check_file" ]]; then
        local last_check
        last_check=$(cat "$check_file" 2>/dev/null || echo "0")
        local now
        now=$(date +%s)
        if (( now - last_check < one_day )); then
            return 0
        fi
    fi

    # Fetch remote version (with short timeout to avoid slowing down runs)
    local remote_version=""
    if command -v curl &> /dev/null; then
        remote_version=$(curl -fsSL --connect-timeout 2 --max-time 5 "$VERSION_URL" 2>/dev/null | tr -d '[:space:]') || true
    elif command -v wget &> /dev/null; then
        remote_version=$(wget -qO- --timeout=2 "$VERSION_URL" 2>/dev/null | tr -d '[:space:]') || true
    fi

    # Update check timestamp
    date +%s > "$check_file" 2>/dev/null || true

    # Compare versions
    if [[ -n "$remote_version" && "$remote_version" != "$VERSION" ]]; then
        # Robust version comparison (semver-aware when sort -V is available)
        if version_gt "$remote_version" "$VERSION"; then
            echo -e "${YELLOW}[giil]${NC} Update available: ${VERSION} ‚Üí ${remote_version}" >&2
            echo -e "${YELLOW}[giil]${NC} Run: curl -fsSL https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/main/install.sh | bash" >&2
        fi
    fi
}

# -----------------------------------------------------------------------------
# Gum (charmbracelet) integration for beautiful CLI
# -----------------------------------------------------------------------------

try_install_gum() {
    # Inline OS detection (detect_os is defined later)
    local os="unknown"
    case "$(uname -s)" in
        Darwin*) os="macos" ;;
        Linux*)  os="linux" ;;
    esac

    # Try to install gum quietly, don't fail if it doesn't work
    case "$os" in
        macos)
            if command -v brew &> /dev/null; then
                brew install gum &>/dev/null && return 0
            fi
            ;;
        linux)
            # Try common package managers
            if command -v apt-get &> /dev/null; then
                # Add charmbracelet repo and install
                (
                    sudo mkdir -p /etc/apt/keyrings 2>/dev/null
                    curl -fsSL https://repo.charm.sh/apt/gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/charm.gpg 2>/dev/null
                    echo "deb [signed-by=/etc/apt/keyrings/charm.gpg] https://repo.charm.sh/apt/ * *" | sudo tee /etc/apt/sources.list.d/charm.list >/dev/null
                    sudo apt-get update -qq && sudo apt-get install -y -qq gum
                ) &>/dev/null && return 0
            elif command -v dnf &> /dev/null; then
                (
                    echo '[charm]
name=Charm
baseurl=https://repo.charm.sh/yum/
enabled=1
gpgcheck=1
gpgkey=https://repo.charm.sh/yum/gpg.key' | sudo tee /etc/yum.repos.d/charm.repo >/dev/null
                    sudo dnf install -y gum
                ) &>/dev/null && return 0
            elif command -v pacman &> /dev/null; then
                sudo pacman -S --noconfirm gum &>/dev/null && return 0
            fi

            # Fallback: try downloading from GitHub releases
            local arch
            arch=$(uname -m)
            case "$arch" in
                x86_64) arch="amd64" ;;
                aarch64|arm64) arch="arm64" ;;
                *) return 1 ;;
            esac

            local tmp_dir
            tmp_dir=$(mktemp -d)
            local gum_version="0.14.5"
            local gum_url="https://github.com/charmbracelet/gum/releases/download/v${gum_version}/gum_${gum_version}_Linux_${arch}.tar.gz"

            (
                cd "$tmp_dir"
                curl -fsSL "$gum_url" -o gum.tar.gz
                tar -xzf gum.tar.gz
                sudo mv gum /usr/local/bin/gum 2>/dev/null || {
                    mkdir -p ~/.local/bin
                    mv gum ~/.local/bin/gum
                }
            ) &>/dev/null && rm -rf "$tmp_dir" && return 0

            rm -rf "$tmp_dir"
            ;;
    esac

    return 1
}

# Version comparison helper: returns 0 if $1 > $2
version_gt() {
    if command -v sort &> /dev/null && printf '%s\n' "$1" "$2" | sort -V >/dev/null 2>&1; then
        [[ "$(printf '%s\n' "$1" "$2" | sort -V | tail -n1)" == "$1" && "$1" != "$2" ]]
    else
        [[ "$1" > "$2" ]]
    fi
}

check_gum() {
    if command -v gum &> /dev/null; then
        GUM_AVAILABLE=true
        return 0
    fi

    # Only try to install gum if not in a CI environment and terminal is interactive
    if [[ -t 1 && -z "${CI:-}" && -z "${GIIL_NO_GUM:-}" ]]; then
        # Try to install gum silently
        if try_install_gum; then
            if [[ -x "${HOME}/.local/bin/gum" && ":$PATH:" != *":${HOME}/.local/bin:"* ]]; then
                export PATH="${HOME}/.local/bin:${PATH}"
            fi
            if command -v gum &> /dev/null; then
                GUM_AVAILABLE=true
                return 0
            fi
        fi
    fi

    return 1
}

# -----------------------------------------------------------------------------
# Styled output functions (use gum if available, fallback to ANSI)
# -----------------------------------------------------------------------------

# Print styled header/banner
print_banner() {
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style \
            --border double \
            --border-foreground 212 \
            --padding "0 2" \
            --margin "1 0" \
            --bold \
            "üçé giil v${VERSION}" \
            "Get iCloud Image Link"
    else
        echo -e "\n${BOLD}${MAGENTA}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}" >&2
        echo -e "${BOLD}${MAGENTA}‚ïë${NC}  ${BOLD}üçé giil v${VERSION}${NC}                    ${BOLD}${MAGENTA}‚ïë${NC}" >&2
        echo -e "${BOLD}${MAGENTA}‚ïë${NC}  ${DIM}Get iCloud Image Link${NC}             ${BOLD}${MAGENTA}‚ïë${NC}" >&2
        echo -e "${BOLD}${MAGENTA}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}\n" >&2
    fi
}

# Show quick start guide optimized for coding agents
show_quickstart() {
    # Initialize gum first
    check_gum || true

    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        # Beautiful gum-styled output
        gum style \
            --border rounded \
            --border-foreground 212 \
            --padding "1 2" \
            --margin "1" \
            --bold \
            "üçé giil v${VERSION} ‚Äî Get iCloud Image Link"

        echo ""

        gum style --foreground 214 --bold "SYNOPSIS"
        echo "  giil <URL> [OPTIONS]"
        echo ""

        gum style --foreground 214 --bold "QUICK EXAMPLES"
        gum style --foreground 39 "  # Download single photo ‚Üí stdout: filepath"
        echo "  giil \"https://share.icloud.com/photos/ABC123\""
        echo ""
        gum style --foreground 39 "  # Download with JSON metadata ‚Üí stdout: JSON"
        echo "  giil \"https://share.icloud.com/photos/ABC123\" --json"
        echo ""
        gum style --foreground 39 "  # Download album (all photos)"
        echo "  giil \"https://share.icloud.com/photos/ABC123\" --all --output ./album"
        echo ""
        gum style --foreground 39 "  # Get base64 for embedding"
        echo "  giil \"https://share.icloud.com/photos/ABC123\" --base64"
        echo ""

        gum style --foreground 214 --bold "OPTIONS"
        gum style --faint "  --output DIR     Save to directory (default: .)"
        gum style --faint "  --quality N      JPEG quality 1-100 (default: 85)"
        gum style --faint "  --json           Output: {path,datetime,sourceUrl,method,size,width,height}"
        gum style --faint "  --base64         Output: base64-encoded JPEG"
        gum style --faint "  --all            Download ALL photos from shared album"
        gum style --faint "  --timeout N      Page load timeout seconds (default: 60)"
        gum style --faint "  --debug          Save debug artifacts on failure"
        gum style --faint "  --help           Full documentation"
        echo ""

        gum style --foreground 214 --bold "OUTPUT FORMAT (for agents)"
        gum style --foreground 82 "  stdout:"
        gum style --faint "    Default:  /path/to/icloud_YYYYMMDD_HHMMSS.jpg"
        gum style --faint "    --json:   {\"path\":\"...\",\"datetime\":\"ISO8601\",\"method\":\"network|download\",...}"
        gum style --faint "    --base64: /9j/4AAQSkZJRg... (raw base64, no wrapper)"
        gum style --foreground 208 "  stderr:"
        gum style --faint "    Progress messages, errors (parseable: [giil] prefix)"
        echo ""

        gum style --foreground 214 --bold "CAPTURE METHODS (in priority order)"
        gum style --faint "  1. download        Click Download button (original file)"
        gum style --faint "  2. network         Intercept CDN response (full-res)"
        gum style --faint "  3. element-screenshot   Screenshot <img> element"
        gum style --faint "  4. viewport-screenshot  Screenshot viewport (fallback)"
        echo ""

        gum style --foreground 214 --bold "URL FORMATS (both work)"
        gum style --faint "  https://share.icloud.com/photos/<ID>"
        gum style --faint "  https://www.icloud.com/photos/#<ID>"
        echo ""

        gum style --foreground 245 --italic "First run installs Playwright+Chromium (~200MB, cached in ~/.cache/giil)"

    else
        # Fallback ANSI-styled output
        echo ""
        echo -e "${BOLD}${MAGENTA}‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ${NC}"
        echo -e "${BOLD}${MAGENTA}‚îÇ${NC}  üçé ${BOLD}giil v${VERSION}${NC} ‚Äî Get iCloud Image Link                        ${BOLD}${MAGENTA}‚îÇ${NC}"
        echo -e "${BOLD}${MAGENTA}‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ${NC}"
        echo ""
        echo -e "${BOLD}${YELLOW}SYNOPSIS${NC}"
        echo "  giil <URL> [OPTIONS]"
        echo ""
        echo -e "${BOLD}${YELLOW}QUICK EXAMPLES${NC}"
        echo -e "  ${CYAN}# Download single photo ‚Üí stdout: filepath${NC}"
        echo "  giil \"https://share.icloud.com/photos/ABC123\""
        echo ""
        echo -e "  ${CYAN}# Download with JSON metadata ‚Üí stdout: JSON${NC}"
        echo "  giil \"https://share.icloud.com/photos/ABC123\" --json"
        echo ""
        echo -e "  ${CYAN}# Download album (all photos)${NC}"
        echo "  giil \"https://share.icloud.com/photos/ABC123\" --all --output ./album"
        echo ""
        echo -e "  ${CYAN}# Get base64 for embedding${NC}"
        echo "  giil \"https://share.icloud.com/photos/ABC123\" --base64"
        echo ""
        echo -e "${BOLD}${YELLOW}OPTIONS${NC}"
        echo -e "  ${DIM}--output DIR     Save to directory (default: .)${NC}"
        echo -e "  ${DIM}--quality N      JPEG quality 1-100 (default: 85)${NC}"
        echo -e "  ${DIM}--json           Output: {path,datetime,sourceUrl,method,size,width,height}${NC}"
        echo -e "  ${DIM}--base64         Output: base64-encoded JPEG${NC}"
        echo -e "  ${DIM}--all            Download ALL photos from shared album${NC}"
        echo -e "  ${DIM}--timeout N      Page load timeout seconds (default: 60)${NC}"
        echo -e "  ${DIM}--debug          Save debug artifacts on failure${NC}"
        echo -e "  ${DIM}--help           Full documentation${NC}"
        echo ""
        echo -e "${BOLD}${YELLOW}OUTPUT FORMAT (for agents)${NC}"
        echo -e "  ${GREEN}stdout:${NC}"
        echo -e "    ${DIM}Default:  /path/to/icloud_YYYYMMDD_HHMMSS.jpg${NC}"
        echo -e "    ${DIM}--json:   {\"path\":\"...\",\"datetime\":\"ISO8601\",\"method\":\"network|download\",...}${NC}"
        echo -e "    ${DIM}--base64: /9j/4AAQSkZJRg... (raw base64, no wrapper)${NC}"
        echo -e "  ${YELLOW}stderr:${NC}"
        echo -e "    ${DIM}Progress messages, errors (parseable: [giil] prefix)${NC}"
        echo ""
        echo -e "${BOLD}${YELLOW}CAPTURE METHODS${NC} ${DIM}(in priority order)${NC}"
        echo -e "  ${DIM}1. download           Click Download button (original file)${NC}"
        echo -e "  ${DIM}2. network            Intercept CDN response (full-res)${NC}"
        echo -e "  ${DIM}3. element-screenshot Screenshot <img> element${NC}"
        echo -e "  ${DIM}4. viewport-screenshot Screenshot viewport (fallback)${NC}"
        echo ""
        echo -e "${BOLD}${YELLOW}URL FORMATS${NC} ${DIM}(both work)${NC}"
        echo -e "  ${DIM}https://share.icloud.com/photos/<ID>${NC}"
        echo -e "  ${DIM}https://www.icloud.com/photos/#<ID>${NC}"
        echo ""
        echo -e "${DIM}${ITALIC}First run installs Playwright+Chromium (~200MB, cached in ~/.cache/giil)${NC}"
    fi

    exit 0
}

# Default values
BASE64_OUTPUT=false
JSON_OUTPUT=false
ALL_MODE=false
OUTPUT_DIR="."
QUALITY=85
FORCE_UPDATE=false
DEBUG_MODE=false
TIMEOUT=60
OPTIMIZE_MODE=false
CONVERT_FORMAT=""
PRINT_URL=false
VERBOSE=false
TRACE_MODE=false
DEBUG_DIR=""
URL=""

# XDG-compliant cache directory
CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
GIIL_HOME="${GIIL_HOME:-$CACHE_HOME/giil}"
PLAYWRIGHT_BROWSERS_PATH="${PLAYWRIGHT_BROWSERS_PATH:-$GIIL_HOME/ms-playwright}"

# -----------------------------------------------------------------------------
# Logging functions (with gum integration)
# -----------------------------------------------------------------------------

log_info() {
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum log --level info "$1" >&2
    else
        echo -e "${GREEN}[giil]${NC} $1" >&2
    fi
}

log_warn() {
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum log --level warn "$1" >&2
    else
        echo -e "${YELLOW}[giil]${NC} $1" >&2
    fi
}

log_error() {
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum log --level error "$1" >&2
    else
        echo -e "${RED}[giil]${NC} $1" >&2
    fi
}

log_step() {
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 39 "‚Üí $1" >&2
    else
        echo -e "${BLUE}[giil]${NC} $1" >&2
    fi
}

log_debug() {
    if [[ "$DEBUG_MODE" == "true" ]]; then
        if [[ "$GUM_AVAILABLE" == "true" ]]; then
            gum log --level debug "$1" >&2
        else
            echo -e "${CYAN}[giil:debug]${NC} $1" >&2
        fi
    fi
}

log_success() {
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 82 "‚úì $1" >&2
    else
        echo -e "${GREEN}‚úì${NC} $1" >&2
    fi
}

# -----------------------------------------------------------------------------
# Help and version
# -----------------------------------------------------------------------------

show_help() {
    cat << 'EOF'
giil - Get iCloud Image Link (Hybrid Edition v3.0)
Downloads images from iCloud photo shares with maximum reliability

Usage:
  giil <icloud-photo-url> [options]

Options:
  --base64         Output image as base64 text instead of saving file
  --json           Output JSON with path, datetime, sourceUrl, captureMethod
  --all            Download ALL photos from a shared album (iterates thumbnails)
  --output DIR     Output directory (default: current directory)
  --optimize       Apply MozJPEG optimization (opt-in compression)
  --convert FMT    Convert to format: jpeg, png, webp
  --quality N      JPEG/WebP quality 1-100 (default: 85, with --optimize/--convert)
  --update         Force update Playwright and dependencies
  --debug          Enable debug mode with extra logging and artifacts
  --verbose        Show detailed progress (implies --debug)
  --trace          Enable Playwright tracing for deep debugging
  --print-url      Output resolved direct URL instead of downloading
  --debug-dir DIR  Directory for debug artifacts (default: current)
  --timeout N      Page load timeout in seconds (default: 60)
  --version        Show version information
  --help           Show this help message

v3.0 Behavior Change:
  Original image bytes are now preserved by default (no recompression).
  Use --optimize for MozJPEG compression or --convert for format conversion.

Supported URL formats:
  https://share.icloud.com/photos/<id>
  https://www.icloud.com/photos/#<id>

Capture Strategy (in order of preference):
  1. Click Download button (highest quality, original file)
  2. Intercept CDN response (full-resolution image)
  3. Screenshot image element
  4. Screenshot viewport (last resort)

Output Modes:
  Default:   Prints file path to stdout
  --json:    {"path": "...", "datetime": "...", "sourceUrl": "...", "method": "..."}
  --base64:  Prints base64-encoded JPEG to stdout
  --all:     Downloads all images, outputs one path/JSON per line

Examples:
  # Download single photo
  giil "https://share.icloud.com/photos/02cD9okNHvVd-uuDnPCH3ZEEA"

  # Download to specific directory with lower quality
  giil "https://www.icloud.com/photos/#02cD9okNHvVd" --output ~/Downloads --quality 70

  # Get JSON output for scripting
  giil "https://share.icloud.com/photos/xxx" --json

  # Download entire shared album
  giil "https://share.icloud.com/photos/xxx" --all --output ~/album

EOF
    exit 0
}

show_version() {
    echo "giil version ${VERSION} (Hybrid Edition)"
    exit 0
}

# -----------------------------------------------------------------------------
# OS Detection
# -----------------------------------------------------------------------------

detect_os() {
    case "$(uname -s)" in
        Darwin*) echo "macos" ;;
        Linux*)  echo "linux" ;;
        *)       echo "unknown" ;;
    esac
}

# -----------------------------------------------------------------------------
# Platform Detection (Cloud Service Identification)
# -----------------------------------------------------------------------------
# Detects which cloud service a URL belongs to.
# Returns: icloud | dropbox | gphotos | gdrive | unknown
#
# URL patterns supported (v3.0+):
#   iCloud:       share.icloud.com/photos/* | icloud.com/photos/*
#   Dropbox:      dropbox.com/s/* | dropbox.com/scl/fi/* | dropbox.com/sh/*
#   Google Photos: photos.app.goo.gl/* | photos.google.com/share/*
#   Google Drive: drive.google.com/file/d/* | drive.google.com/open?id=*

detect_platform() {
    local url="$1"
    case "$url" in
        # iCloud photo shares (existing v2.x support)
        *share.icloud.com/photos/* | *icloud.com/photos/*)
            echo "icloud"
            ;;
        # Dropbox shared links (v3.0+)
        *dropbox.com/s/* | *dropbox.com/scl/fi/* | *dropbox.com/sh/*)
            echo "dropbox"
            ;;
        # Google Photos shared albums/photos (v3.0+)
        *photos.app.goo.gl/* | *photos.google.com/share/*)
            echo "gphotos"
            ;;
        # Google Drive file links (v3.0+ experimental)
        *drive.google.com/file/d/* | *drive.google.com/open?id=*)
            echo "gdrive"
            ;;
        *)
            echo "unknown"
            ;;
    esac
}

# -----------------------------------------------------------------------------
# URL Normalization (v3.0+ - platform-specific URL transformations)
# -----------------------------------------------------------------------------

# Normalize Dropbox share URL to direct download URL
# Replaces dl=0|1 or raw=0|1 with raw=1 for direct binary access with correct MIME type
normalize_dropbox_url() {
    local url="$1"

    # Remove existing dl= or raw= parameters
    url=$(echo "$url" | sed -E 's/[&?](dl|raw)=[01]//g')

    # Clean up any double && or trailing ?/& from removal
    url=$(echo "$url" | sed -E 's/\?&/?/; s/&&/\&/g; s/[?&]$//')

    # Add raw=1 parameter (raw=1 provides correct Content-Type, unlike dl=1)
    if [[ "$url" == *"?"* ]]; then
        echo "${url}&raw=1"
    else
        echo "${url}?raw=1"
    fi
}

# -----------------------------------------------------------------------------
# Dependency Management
# -----------------------------------------------------------------------------

install_node_macos() {
    if command -v brew &> /dev/null; then
        log_info "Installing Node.js via Homebrew..."
        brew install node
    else
        log_error "Homebrew not found. Please install Node.js manually:"
        log_error "  https://nodejs.org/ or 'brew install node'"
        exit "$EXIT_DEPENDENCY_ERROR"
    fi
}

install_node_linux() {
    if command -v apt-get &> /dev/null; then
        log_info "Installing Node.js via apt..."
        sudo apt-get update
        sudo apt-get install -y nodejs npm
    elif command -v dnf &> /dev/null; then
        log_info "Installing Node.js via dnf..."
        sudo dnf install -y nodejs npm
    elif command -v yum &> /dev/null; then
        log_info "Installing Node.js via yum..."
        sudo yum install -y nodejs npm
    elif command -v pacman &> /dev/null; then
        log_info "Installing Node.js via pacman..."
        sudo pacman -S --noconfirm nodejs npm
    else
        log_error "Could not detect package manager. Please install Node.js manually:"
        log_error "  https://nodejs.org/"
        exit "$EXIT_DEPENDENCY_ERROR"
    fi
}

ensure_node() {
    if ! command -v node &> /dev/null; then
        log_warn "Node.js not found. Installing..."
        local os
        os=$(detect_os)
        case "$os" in
            macos) install_node_macos ;;
            linux) install_node_linux ;;
            *)
                log_error "Unsupported OS. Please install Node.js manually."
                exit "$EXIT_DEPENDENCY_ERROR"
                ;;
        esac
    fi

    local node_version
    node_version=$(node --version | sed 's/v//' | cut -d. -f1)
    if [[ "$node_version" -lt 18 ]]; then
        log_warn "Node.js v18+ recommended. Current: $(node --version)"
    fi

    log_debug "Node.js $(node --version)"
}

ensure_playwright() {
    local package_json="${GIIL_HOME}/package.json"
    local lock_file="${GIIL_HOME}/.installed"

    mkdir -p "$GIIL_HOME"

    # Check if we need to install or update
    local needs_install=false
    if [[ ! -f "$lock_file" ]] || [[ ! -d "${GIIL_HOME}/node_modules/playwright" ]]; then
        needs_install=true
    fi
    if [[ "$FORCE_UPDATE" == "true" ]]; then
        needs_install=true
        log_info "Forcing dependency update..."
        rm -f "$lock_file"
    fi

    if [[ "$needs_install" == "true" ]]; then
        # Show prominent first-run message
        echo "" >&2
        if [[ "$GUM_AVAILABLE" == "true" ]]; then
            gum style \
                --foreground 212 \
                --border rounded \
                --border-foreground 212 \
                --padding "0 2" \
                --bold \
                "‚è≥ INITIAL SETUP ‚Äî Please be patient!" \
                "" \
                "Installing Playwright + Chromium (~200MB)" \
                "This only happens once, then it's cached." >&2
        else
            echo -e "${BOLD}${YELLOW}‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ${NC}" >&2
            echo -e "${BOLD}${YELLOW}‚îÇ${NC}  ‚è≥ ${BOLD}INITIAL SETUP ‚Äî Please be patient!${NC}          ${BOLD}${YELLOW}‚îÇ${NC}" >&2
            echo -e "${BOLD}${YELLOW}‚îÇ${NC}                                                 ${BOLD}${YELLOW}‚îÇ${NC}" >&2
            echo -e "${BOLD}${YELLOW}‚îÇ${NC}  Installing Playwright + Chromium (~200MB)      ${BOLD}${YELLOW}‚îÇ${NC}" >&2
            echo -e "${BOLD}${YELLOW}‚îÇ${NC}  This only happens once, then it's cached.      ${BOLD}${YELLOW}‚îÇ${NC}" >&2
            echo -e "${BOLD}${YELLOW}‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ${NC}" >&2
        fi
        echo "" >&2

        # Create package.json with all dependencies
        cat > "$package_json" << 'PACKAGE_EOF'
{
  "name": "giil-runtime",
  "version": "3.0.0",
  "private": true,
  "type": "module",
  "dependencies": {
    "playwright": "1.40.0",
    "sharp": "0.33.0",
    "exifr": "7.1.3"
  }
}
PACKAGE_EOF

        cd "$GIIL_HOME"
        log_step "Installing npm packages..."
        npm install --silent --no-fund --no-audit --include=optional 2>/dev/null || \
            npm install --no-fund --no-audit --include=optional

        # Verify sharp runtime is usable; install platform-specific prebuilds if needed.
        if ! node -e "require('sharp')" >/dev/null 2>&1; then
            log_warn "Sharp runtime missing; attempting platform-specific install..."
            local os
            os=$(detect_os)
            local arch
            arch=$(uname -m)
            local sharp_pkg=""
            local vips_pkg=""
            local sharp_pkg_version=""
            local vips_pkg_version=""

            case "$os" in
                linux)
                    case "$arch" in
                        x86_64|amd64)
                            sharp_pkg="@img/sharp-linux-x64"
                            vips_pkg="@img/sharp-libvips-linux-x64"
                            ;;
                        aarch64|arm64)
                            sharp_pkg="@img/sharp-linux-arm64"
                            vips_pkg="@img/sharp-libvips-linux-arm64"
                            ;;
                    esac
                    ;;
                macos)
                    case "$arch" in
                        x86_64|amd64)
                            sharp_pkg="@img/sharp-darwin-x64"
                            vips_pkg="@img/sharp-libvips-darwin-x64"
                            ;;
                        arm64)
                            sharp_pkg="@img/sharp-darwin-arm64"
                            vips_pkg="@img/sharp-libvips-darwin-arm64"
                            ;;
                    esac
                    ;;
            esac

            if [[ -n "$sharp_pkg" && -n "$vips_pkg" ]]; then
                sharp_pkg_version=$(node -p "require('./node_modules/sharp/package.json').optionalDependencies['${sharp_pkg}'] || ''" 2>/dev/null || echo "")
                vips_pkg_version=$(node -p "require('./node_modules/sharp/package.json').optionalDependencies['${vips_pkg}'] || ''" 2>/dev/null || echo "")

                if [[ -n "$sharp_pkg_version" && -n "$vips_pkg_version" ]]; then
                    npm install --no-fund --no-audit --force "${sharp_pkg}@${sharp_pkg_version}" "${vips_pkg}@${vips_pkg_version}"
                else
                    npm install --no-fund --no-audit --force "$sharp_pkg" "$vips_pkg"
                fi
            else
                log_warn "No prebuilt sharp packages available for ${os}/${arch}"
            fi

            if ! node -e "require('sharp')" >/dev/null 2>&1; then
                log_error "Sharp failed to install. Try reinstalling dependencies or set GIIL_HOME to a writable path."
                exit "$EXIT_DEPENDENCY_ERROR"
            fi
        fi

        log_step "Installing Chromium browser..."
        export PLAYWRIGHT_BROWSERS_PATH
        npx playwright install chromium 2>&1 | sed '/^$/d' || {
            local os
            os=$(detect_os)
            if [[ "$os" == "linux" ]]; then
                log_warn "Trying with system dependencies (may require sudo)..."
                npx playwright install --with-deps chromium 2>&1 | sed '/^$/d' || {
                    log_error "Failed to install Chromium. Try manually:"
                    log_error "  npx playwright install --with-deps chromium"
                    exit "$EXIT_DEPENDENCY_ERROR"
                }
            else
                log_error "Failed to install Chromium. Try manually:"
                log_error "  npx playwright install chromium"
                exit "$EXIT_DEPENDENCY_ERROR"
            fi
        }

        touch "$lock_file"
        log_info "Setup complete!"
    fi

    export PLAYWRIGHT_BROWSERS_PATH
}

# -----------------------------------------------------------------------------
# Node.js Extractor Script (Hybrid approach with --all and --json support)
# -----------------------------------------------------------------------------

create_extractor_script() {
    local script_path="${GIIL_HOME}/extractor.mjs"

    cat > "$script_path" << 'SCRIPT_EOF'
import { chromium } from 'playwright';
import sharp from 'sharp';
import exifr from 'exifr';
import { writeFileSync, readFileSync, existsSync, unlinkSync } from 'fs';
import { join, basename } from 'path';
import { execFileSync } from 'child_process';

// -----------------------------------------------------------------------------
// Exit Codes (v3.0+ - must match bash layer)
// -----------------------------------------------------------------------------
const ExitCodes = {
    SUCCESS: 0,           // Success
    CAPTURE_FAILURE: 1,   // All capture strategies failed
    USAGE_ERROR: 2,       // Bad CLI options
    DEPENDENCY_ERROR: 3,  // Node.js/Playwright missing
    NETWORK_ERROR: 10,    // Timeout, DNS, unreachable
    AUTH_REQUIRED: 11,    // Login redirect, password required
    NOT_FOUND: 12,        // Expired link, deleted, 404
    UNSUPPORTED_TYPE: 13, // Video, Google Doc
    INTERNAL_ERROR: 20    // Bug in giil
};

// -----------------------------------------------------------------------------
// Rate Limiting (v3.0+ - polite delays for album downloads)
// -----------------------------------------------------------------------------
const ALBUM_DELAY_MS = 1000;        // 1 second between photos in album mode
const RATE_LIMIT_BACKOFF_BASE = 2;  // Base for exponential backoff (2^retries seconds)
const MAX_RETRIES = 3;              // Max retries for rate-limited requests

// =============================================================================
// Platform Adapter Interface (v3.0+ - JSDoc for type hints)
// =============================================================================
// These typedefs define the contract that all platform adapters must implement.
// Using JSDoc instead of TypeScript avoids build complexity for embedded script.

/**
 * A resolved item from a URL (single image or album entry)
 * @typedef {Object} ResolvedItem
 * @property {string} url - The original or normalized URL
 * @property {string} [directUrl] - Direct download URL if available (bypasses browser)
 * @property {string} [filename] - Suggested filename from URL/headers
 * @property {number} [index] - Position in album (for --all mode)
 */

/**
 * Result from acquiring image bytes
 * @typedef {Object} AcquireResult
 * @property {Buffer} bytes - The raw image data
 * @property {string} mime - MIME type (image/jpeg, image/png, etc.)
 * @property {string} platform - Platform identifier (icloud, dropbox, gphotos, gdrive)
 * @property {string} method - Capture method used (download, network, element-screenshot, viewport-screenshot)
 * @property {number} tier - Strategy tier (1=download, 2=network, 3=element, 4=viewport)
 * @property {string} [sourceUrl] - CDN URL where image was obtained
 * @property {boolean} [isPreview] - True if this is preview quality (not full resolution)
 * @property {number} [width] - Image width in pixels
 * @property {number} [height] - Image height in pixels
 */

/**
 * Context passed to acquire functions
 * @typedef {Object} AcquireContext
 * @property {import('playwright').Page} page - Playwright page instance
 * @property {import('playwright').BrowserContext} context - Browser context
 * @property {number} timeout - Timeout in milliseconds
 * @property {boolean} debug - Whether debug mode is enabled
 * @property {string} outputDir - Output directory for saved files
 * @property {number} quality - JPEG quality (1-100)
 */

/**
 * Platform adapter interface - all platform handlers must implement this
 * @typedef {Object} PlatformAdapter
 * @property {'icloud'|'dropbox'|'gphotos'|'gdrive'} id - Platform identifier
 * @property {(url: string) => boolean} match - Test if URL belongs to this platform
 * @property {(url: string) => string} normalize - Normalize URL to canonical form
 * @property {(url: string, opts: {all: boolean}) => Promise<ResolvedItem[]>} resolveItems - Resolve URL to downloadable items
 * @property {(item: ResolvedItem, ctx: AcquireContext) => Promise<AcquireResult>} acquire - Acquire image bytes for an item
 * @property {boolean} [requiresBrowser] - True if platform needs Playwright (false for direct downloads like Dropbox)
 */

// Parse arguments
const args = process.argv.slice(2);
const url = args[0];
const outputDir = args[1] || '.';
const quality = parseInt(args[2] || '85', 10);
const base64Output = args[3] === 'true';
const debugMode = args[4] === 'true';
const timeoutSec = parseInt(args[5] || '60', 10);
const jsonOutput = args[6] === 'true';
const allMode = args[7] === 'true';
const optimizeMode = args[8] === 'true';
const convertFormat = args[9] || '';  // 'jpeg', 'png', 'webp', or ''
const verboseMode = args[10] === 'true';
const traceMode = args[11] === 'true';
const printUrlMode = args[12] === 'true';
const debugDir = args[13] || '';

// Verbose logging helper
function verbose(msg) {
    if (verboseMode) console.error(`[giil] ${msg}`);
}

if (!url) {
    console.error('Usage: node extractor.mjs <url> <outputDir> <quality> <base64> <debug> <timeout> <json> <all> <optimize> <convert> <verbose> <trace> <printUrl> <debugDir>');
    process.exit(ExitCodes.USAGE_ERROR);
}

// Helper: sleep
const sleep = (ms) => new Promise(r => setTimeout(r, ms));

// Helper: format date for filename (YYYYMMDD_HHMMSS)
function formatDateForFilename(date) {
    const pad = (n) => String(n).padStart(2, '0');
    return `${date.getFullYear()}${pad(date.getMonth() + 1)}${pad(date.getDate())}_` +
           `${pad(date.getHours())}${pad(date.getMinutes())}${pad(date.getSeconds())}`;
}

// Helper: format date for JSON (ISO 8601)
function formatDateForJson(date) {
    return date.toISOString();
}

// Helper: detect platform from URL (v3.0+)
// Patterns use domain boundaries to prevent matching subdomains like fakedropbox.com
function detectPlatform(urlStr) {
    const patterns = {
        // icloud.com or share.icloud.com (preceded by // or .)
        icloud: /(?:\/\/|\.)?(?:share\.)?icloud\.com\/photos/i,
        // dropbox.com (preceded by // or .)
        dropbox: /(?:\/\/|\.)dropbox\.com\/(?:s|scl\/fi|sh)\//i,
        // photos.app.goo.gl or photos.google.com (preceded by // or .)
        gphotos: /(?:\/\/|\.)photos\.(?:app\.goo\.gl|google\.com\/share)/i,
        // drive.google.com or docs.google.com (preceded by // or .)
        gdrive: /(?:\/\/|\.)(?:drive|docs)\.google\.com\/(?:file\/d|open\?id)/i
    };

    for (const [platform, regex] of Object.entries(patterns)) {
        if (regex.test(urlStr)) return platform;
    }
    return 'unknown';
}

// Current platform (detected from input URL)
const currentPlatform = detectPlatform(url);

// -----------------------------------------------------------------------------
// Google Photos URL Helpers (v3.0+)
// -----------------------------------------------------------------------------
// Google Photos CDN URLs have size modifiers after '=' (e.g., =w1920-h1080)
// To get full resolution, use =s0 (original size) or =d (download)

/**
 * Extract base URL from Google Photos CDN URL and return full-res version
 * @param {string} cdnUrl - The CDN URL with size modifier
 * @returns {{baseUrl: string, fullResUrl: string}} Base and full-resolution URLs
 */
function extractGooglePhotosBaseUrl(cdnUrl) {
    // Remove size modifier (everything after last '=' in the path)
    // Example: https://lh3.googleusercontent.com/pw/ABC123=w1920-h1080
    //       -> https://lh3.googleusercontent.com/pw/ABC123
    const eqIndex = cdnUrl.lastIndexOf('=');
    const baseUrl = eqIndex > 0 ? cdnUrl.substring(0, eqIndex) : cdnUrl;

    // =s0 means original size, =d means download (both give full resolution)
    const fullResUrl = `${baseUrl}=s0`;

    return { baseUrl, fullResUrl };
}

/**
 * Try to download full-resolution image from Google Photos CDN
 * @param {string} cdnUrl - The captured CDN URL
 * @returns {Promise<{buffer: Buffer, url: string}|null>} Buffer and URL or null if failed
 */
async function downloadGooglePhotosFullRes(cdnUrl) {
    const { fullResUrl } = extractGooglePhotosBaseUrl(cdnUrl);

    try {
        // Use native fetch (available in Node 18+)
        const response = await fetch(fullResUrl, {
            headers: {
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'
            }
        });

        if (!response.ok) {
            console.error(`[giil] Google Photos full-res download failed: HTTP ${response.status}`);
            return null;
        }

        const buffer = Buffer.from(await response.arrayBuffer());
        console.error(`[giil] Downloaded Google Photos full-res: ${(buffer.length / 1024).toFixed(1)} KB`);
        return { buffer, url: fullResUrl };
    } catch (e) {
        console.error(`[giil] Google Photos download error: ${e.message}`);
        return null;
    }
}

// -----------------------------------------------------------------------------
// Google Drive URL Helpers (v3.0+)
// -----------------------------------------------------------------------------
// Google Drive shares various URL formats that all contain a file ID.
// Once extracted, we can construct direct download URLs.

/**
 * Extract file ID from various Google Drive URL formats
 * @param {string} urlStr - The Google Drive URL
 * @returns {string|null} File ID or null if not found
 */
function extractGoogleDriveFileId(urlStr) {
    const patterns = [
        /\/file\/d\/([a-zA-Z0-9_-]+)/,      // /file/d/{id}/view
        /\/open\?id=([a-zA-Z0-9_-]+)/,       // /open?id={id}
        /[?&]id=([a-zA-Z0-9_-]+)/            // ?id={id} or &id={id}
    ];

    for (const pattern of patterns) {
        const match = urlStr.match(pattern);
        if (match) return match[1];
    }
    return null;
}

/**
 * Construct direct download URL for Google Drive file
 * @param {string} fileId - The extracted file ID
 * @returns {string} Direct download URL (may require auth)
 */
function getGoogleDriveDownloadUrl(fileId) {
    // This URL works for publicly shared files with "Anyone with the link" access
    return `https://drive.google.com/uc?export=download&id=${fileId}`;
}

/**
 * Construct viewer URL for Google Drive file
 * @param {string} fileId - The extracted file ID
 * @returns {string} Viewer URL
 */
function getGoogleDriveViewerUrl(fileId) {
    return `https://drive.google.com/file/d/${fileId}/view`;
}

/**
 * Check if Google Drive page indicates authentication is required
 * @param {import('playwright').Page} page - Playwright page instance
 * @returns {Promise<{needsAuth: boolean, reason: string|null}>}
 */
async function checkGoogleDriveAuth(page) {
    const currentUrl = page.url();

    // Check for login redirect
    if (currentUrl.includes('accounts.google.com')) {
        return {
            needsAuth: true,
            reason: 'File requires authentication. Set sharing to "Anyone with the link".'
        };
    }

    // Check for "request access" page
    try {
        const requestAccessBtn = await page.$('button:has-text("Request access")');
        if (requestAccessBtn) {
            return {
                needsAuth: true,
                reason: 'File is restricted. Owner must grant access or share publicly.'
            };
        }
    } catch (e) {
        // Selector didn't match, that's fine
    }

    // Check for common error indicators in page content
    try {
        const content = await page.content();
        if (content.includes('You need permission') ||
            content.includes('Request access') ||
            content.includes('sign in to continue')) {
            return {
                needsAuth: true,
                reason: 'Access denied. File is not publicly shared.'
            };
        }
        if (content.includes('Sorry, the file you have requested does not exist') ||
            content.includes('Sorry, unable to open the file')) {
            return {
                needsAuth: false,
                reason: 'FILE_NOT_FOUND: File may have been deleted or link is invalid.'
            };
        }
    } catch (e) {
        // Page content not accessible
    }

    return { needsAuth: false, reason: null };
}

/**
 * Validate that a response buffer is not an HTML error page
 * @param {Buffer} buffer - Response buffer to check
 * @returns {{isError: boolean, errorType: string|null, message: string|null}}
 */
function validateGoogleDriveResponse(buffer) {
    if (!buffer || buffer.length < 100) {
        return { isError: true, errorType: 'EMPTY_RESPONSE', message: 'Empty or too small response' };
    }

    // Check first 1KB for HTML error indicators
    const text = buffer.toString('utf8', 0, Math.min(buffer.length, 1000));

    if (text.includes('accounts.google.com/ServiceLogin') ||
        text.includes('accounts.google.com/signin')) {
        return {
            isError: true,
            errorType: 'AUTH_REQUIRED',
            message: 'Login required. File is not publicly shared.'
        };
    }

    if (text.includes('Request access') || text.includes('You need permission')) {
        return {
            isError: true,
            errorType: 'AUTH_REQUIRED',
            message: 'Access denied. File is restricted.'
        };
    }

    if (text.includes('Sorry, the file you have requested does not exist') ||
        text.includes('file could not be found')) {
        return {
            isError: true,
            errorType: 'NOT_FOUND',
            message: 'File not found. May have been deleted or link is invalid.'
        };
    }

    // Check if response looks like HTML (not an image)
    if (text.trim().startsWith('<!DOCTYPE') || text.trim().startsWith('<html')) {
        return {
            isError: true,
            errorType: 'HTML_ERROR',
            message: 'Received HTML instead of image. File may not be accessible.'
        };
    }

    return { isError: false, errorType: null, message: null };
}

/**
 * Multi-tier capture strategy for Google Drive files
 * @param {import('playwright').Page} page - Playwright page
 * @param {string} fileId - Google Drive file ID
 * @param {boolean} debugMode - Debug logging
 * @returns {Promise<Object|null>} Capture result or null
 */
async function captureGoogleDrive(page, fileId, debugMode) {
    // TIER 1: Download button
    if (debugMode) console.error('[giil:debug] GDrive: Trying download button...');
    try {
        for (const sel of ['button[aria-label="Download"]', '[data-tooltip="Download"]']) {
            const btn = await page.$(sel);
            if (btn) {
                const dlPromise = page.waitForEvent('download', { timeout: 10000 });
                await btn.click();
                const dl = await dlPromise;
                const path = await dl.path();
                if (path) {
                    const buf = readFileSync(path);
                    console.error('[giil] GDrive download: ' + (buf.length / 1024).toFixed(1) + ' KB');
                    return { bytes: buf, method: 'download-button', tier: 1, sourceUrl: getGoogleDriveViewerUrl(fileId) };
                }
            }
        }
    } catch (e) { if (debugMode) console.error('[giil:debug] Download failed: ' + e.message); }

    // TIER 2: Direct URL
    if (debugMode) console.error('[giil:debug] GDrive: Trying direct URL...');
    try {
        const url = getGoogleDriveDownloadUrl(fileId);
        const res = await fetch(url, { redirect: 'follow' });
        if (res.ok && (res.headers.get('content-type') || '').startsWith('image/')) {
            const buf = Buffer.from(await res.arrayBuffer());
            if (!validateGoogleDriveResponse(buf).isError) {
                console.error('[giil] GDrive direct: ' + (buf.length / 1024).toFixed(1) + ' KB');
                return { bytes: buf, method: 'direct-url', tier: 2, sourceUrl: url };
            }
        }
    } catch (e) { if (debugMode) console.error('[giil:debug] Direct failed: ' + e.message); }

    // TIER 3: Thumbnail
    if (debugMode) console.error('[giil:debug] GDrive: Trying thumbnail...');
    try {
        const url = 'https://drive.google.com/thumbnail?id=' + fileId + '&sz=w4000';
        const res = await fetch(url);
        if (res.ok) {
            const buf = Buffer.from(await res.arrayBuffer());
            if (validateMagicBytes(buf).isImage) {
                console.error('[giil] GDrive thumbnail: ' + (buf.length / 1024).toFixed(1) + ' KB');
                return { bytes: buf, method: 'thumbnail', tier: 3, sourceUrl: url, isPreview: true };
            }
        }
    } catch (e) { if (debugMode) console.error('[giil:debug] Thumbnail failed: ' + e.message); }

    // TIER 4: Screenshot
    if (debugMode) console.error('[giil:debug] GDrive: Screenshot fallback...');
    try {
        for (const sel of ['img[src*="drive.google.com"]', '[role="img"]']) {
            const el = await page.$(sel);
            if (el && await el.isVisible().catch(() => false)) {
                const box = await el.boundingBox();
                if (box && box.width > 100 && box.height > 100) {
                    const buf = await el.screenshot({ type: 'png' });
                    console.error('[giil] GDrive element screenshot: ' + (buf.length / 1024).toFixed(1) + ' KB');
                    return { bytes: buf, method: 'element-screenshot', tier: 4, sourceUrl: getGoogleDriveViewerUrl(fileId) };
                }
            }
        }
        const buf = await page.screenshot({ type: 'png' });
        return { bytes: buf, method: 'viewport-screenshot', tier: 4, sourceUrl: getGoogleDriveViewerUrl(fileId) };
    } catch (e) { console.error('[giil] GDrive screenshot failed: ' + e.message); }

    return null;
}

// v3 JSON Schema Helper: format success output
// Wraps all output with schema_version, ok, and platform fields
function formatJsonSuccess(data) {
    return {
        schema_version: '1',
        ok: true,
        platform: currentPlatform,
        ...data
    };
}

// v3 JSON Schema Helper: format error output
function formatJsonError(code, message, remediation = null) {
    const result = {
        schema_version: '1',
        ok: false,
        platform: currentPlatform,
        error: {
            code: code,
            message: message
        }
    };
    if (remediation) {
        result.error.remediation = remediation;
    }
    return result;
}

// Error code to exit code mapping
const errorCodeToExit = {
    'CAPTURE_FAILURE': ExitCodes.CAPTURE_FAILURE,
    'USAGE_ERROR': ExitCodes.USAGE_ERROR,
    'NETWORK_ERROR': ExitCodes.NETWORK_ERROR,
    'AUTH_REQUIRED': ExitCodes.AUTH_REQUIRED,
    'NOT_FOUND': ExitCodes.NOT_FOUND,
    'UNSUPPORTED_TYPE': ExitCodes.UNSUPPORTED_TYPE,
    'INTERNAL_ERROR': ExitCodes.INTERNAL_ERROR,
    'CONTENT_TYPE_HTML': ExitCodes.AUTH_REQUIRED,
    'MAGIC_BYTES_HTML': ExitCodes.AUTH_REQUIRED
};

// Helper: extract EXIF datetime from buffer
async function getExifDateTime(buffer) {
    try {
        const exif = await exifr.parse(buffer, {
            pick: ['DateTimeOriginal', 'CreateDate', 'ModifyDate', 'DateTimeDigitized']
        });
        if (exif) {
            const dt = exif.DateTimeOriginal || exif.CreateDate ||
                       exif.DateTimeDigitized || exif.ModifyDate;
            if (dt instanceof Date && !isNaN(dt.getTime())) {
                return dt;
            }
        }
    } catch (e) {
        // EXIF parsing failed, will use current time
    }
    return null;
}

// Helper: try HEIC conversion with system tools (synchronous)
function convertHeicWithSystemTools(inputPath, outputPath) {
    const platform = process.platform;
    try {
        if (platform === 'darwin') {
            execFileSync('sips', ['-s', 'format', 'jpeg', inputPath, '--out', outputPath], { stdio: 'ignore' });
            return true;
        } else if (platform === 'linux') {
            execFileSync('heif-convert', [inputPath, outputPath], { stdio: 'ignore' });
            return true;
        }
    } catch (e) {
        // System tool not available or failed
    }
    return false;
}

// -----------------------------------------------------------------------------
// Content Validation (v3.0+ - detect HTML error pages masquerading as images)
// -----------------------------------------------------------------------------

// Validate Content-Type header from HTTP response
// Returns: { valid: boolean, contentType: string, isHtml: boolean }
function validateContentType(contentType) {
    const normalizedType = (contentType || '').toLowerCase();

    const validImageTypes = [
        'image/jpeg', 'image/png', 'image/gif',
        'image/webp', 'image/heic', 'image/heif',
        'image/tiff', 'image/bmp',
        'application/octet-stream'  // Some CDNs use this for binary files
    ];

    // Explicit HTML detection - this is an error page
    const isHtml = normalizedType.includes('text/html') ||
                   normalizedType.includes('application/xhtml');

    if (isHtml) {
        return { valid: false, contentType: normalizedType, isHtml: true };
    }

    const valid = validImageTypes.some(t => normalizedType.includes(t));
    return { valid, contentType: normalizedType, isHtml: false };
}

// Validate magic bytes (file signature) to detect actual content type
// Returns: { format: string, isHtml: boolean, isImage: boolean }
function validateMagicBytes(buffer) {
    if (!buffer || buffer.length < 12) {
        return { format: 'unknown', isHtml: false, isImage: false };
    }

    const head = buffer.slice(0, 12);

    // JPEG: FF D8 FF
    if (head[0] === 0xFF && head[1] === 0xD8 && head[2] === 0xFF) {
        return { format: 'jpeg', isHtml: false, isImage: true };
    }

    // PNG: 89 50 4E 47 0D 0A 1A 0A
    if (head[0] === 0x89 && head[1] === 0x50 && head[2] === 0x4E && head[3] === 0x47) {
        return { format: 'png', isHtml: false, isImage: true };
    }

    // GIF: 47 49 46 38 (GIF8)
    if (head[0] === 0x47 && head[1] === 0x49 && head[2] === 0x46 && head[3] === 0x38) {
        return { format: 'gif', isHtml: false, isImage: true };
    }

    // WebP: RIFF....WEBP
    if (head[0] === 0x52 && head[1] === 0x49 && head[2] === 0x46 && head[3] === 0x46) {
        // Check for WEBP at offset 8
        if (buffer.length >= 12 &&
            head[8] === 0x57 && head[9] === 0x45 && head[10] === 0x42 && head[11] === 0x50) {
            return { format: 'webp', isHtml: false, isImage: true };
        }
    }

    // HEIC/HEIF: ftyp box - starts with size (4 bytes) + "ftyp"
    if (buffer.length >= 12 &&
        head[4] === 0x66 && head[5] === 0x74 && head[6] === 0x79 && head[7] === 0x70) {
        // Check for heic, mif1, msf1, or other HEIF brands
        const brand = buffer.slice(8, 12).toString('ascii');
        if (['heic', 'heix', 'mif1', 'msf1', 'hevc'].includes(brand)) {
            return { format: 'heic', isHtml: false, isImage: true };
        }
    }

    // BMP: 42 4D (BM)
    if (head[0] === 0x42 && head[1] === 0x4D) {
        return { format: 'bmp', isHtml: false, isImage: true };
    }

    // TIFF: 49 49 2A 00 (little endian) or 4D 4D 00 2A (big endian)
    if ((head[0] === 0x49 && head[1] === 0x49 && head[2] === 0x2A && head[3] === 0x00) ||
        (head[0] === 0x4D && head[1] === 0x4D && head[2] === 0x00 && head[3] === 0x2A)) {
        return { format: 'tiff', isHtml: false, isImage: true };
    }

    // HTML detection: check for < or whitespace+< at start
    // Convert first bytes to string and check for HTML patterns
    const strHead = head.toString('utf8').trim().toLowerCase();
    if (strHead.startsWith('<!doctype') || strHead.startsWith('<html') ||
        strHead.startsWith('<?xml') || strHead.startsWith('<')) {
        return { format: 'html', isHtml: true, isImage: false };
    }

    // Unknown format - could still be valid (some formats not recognized)
    return { format: 'unknown', isHtml: false, isImage: false };
}

// Combined validation: checks both content-type and magic bytes
// Throws descriptive error if content is HTML (error page)
function validateImageContent(buffer, contentType = null, debugMode = false) {
    // Layer 1: Content-Type header (if available)
    if (contentType) {
        const ctResult = validateContentType(contentType);
        if (ctResult.isHtml) {
            const error = new Error('CONTENT_TYPE_HTML: Server returned HTML instead of image (likely error page or login form)');
            error.code = 'CONTENT_TYPE_HTML';
            error.exitCode = 11;  // AUTH_REQUIRED
            throw error;
        }
        if (debugMode && !ctResult.valid) {
            console.error(`[giil:debug] Unexpected Content-Type: ${ctResult.contentType}`);
        }
    }

    // Layer 2: Magic bytes verification
    const magicResult = validateMagicBytes(buffer);
    if (magicResult.isHtml) {
        const error = new Error('MAGIC_BYTES_HTML: Content is HTML, not an image (likely error page or login form)');
        error.code = 'MAGIC_BYTES_HTML';
        error.exitCode = 11;  // AUTH_REQUIRED
        throw error;
    }

    if (debugMode) {
        console.error(`[giil:debug] Content validated: format=${magicResult.format}, isImage=${magicResult.isImage}`);
    }

    return magicResult;
}

// Helper: generate unique filename with counter if needed
// v3: Added ext parameter for preserving original format
function getUniqueFilename(outputDir, dateStr, index = null, ext = 'jpg') {
    const suffix = index !== null ? `_${String(index).padStart(3, '0')}` : '';
    let filename = `icloud_${dateStr}${suffix}.${ext}`;
    let outputPath = join(outputDir, filename);

    // If file exists, add counter
    let counter = 1;
    while (existsSync(outputPath)) {
        filename = `icloud_${dateStr}${suffix}_${counter}.${ext}`;
        outputPath = join(outputDir, filename);
        counter++;
    }
    return { filename, outputPath };
}

// Process a single image buffer and save/output it
// Default: MozJPEG compression for optimal size/quality. Use --preserve to keep original bytes.
async function processAndSaveImage(buffer, options) {
    const {
        outputDir, quality, base64Output, jsonOutput,
        captureMethod, sourceUrl, downloadedFilePath, index,
        preserve, convert  // preserve=true skips compression
    } = options;

    // Try to get EXIF datetime
    let captureDate = await getExifDateTime(buffer);

    // Default: process with MozJPEG. Skip if --preserve (unless converting)
    const needsProcessing = !preserve || convert;

    // Handle HEIC/HEIF conversion if Sharp can't read the original format
    let processableBuffer = buffer;
    let originalFormat = null;
    let metadata = null;

    try {
        metadata = await sharp(buffer).metadata();
        originalFormat = metadata.format;
    } catch (sharpError) {
        // Sharp can't read the format - likely HEIC/HEIF, need to convert
        const tempJpeg = join(outputDir, `_temp_converted_${Date.now()}.jpg`);
        let didConvert = false;
        let tempInput = null;

        if (downloadedFilePath && existsSync(downloadedFilePath)) {
            didConvert = convertHeicWithSystemTools(downloadedFilePath, tempJpeg);
        } else {
            tempInput = join(outputDir, `_temp_input_${Date.now()}.heic`);
            try {
                writeFileSync(tempInput, buffer);
                didConvert = convertHeicWithSystemTools(tempInput, tempJpeg);
            } catch (e) {
                // Conversion attempt failed; handled below
            } finally {
                if (tempInput && existsSync(tempInput)) {
                    try { unlinkSync(tempInput); } catch (e) {}
                }
            }
        }

        if (didConvert && existsSync(tempJpeg)) {
            processableBuffer = readFileSync(tempJpeg);
            try { unlinkSync(tempJpeg); } catch (e) {}
            console.error('[giil] Converted HEIC using system tools');
            // Re-read metadata from converted buffer
            metadata = await sharp(processableBuffer).metadata();
            originalFormat = 'heic';  // Remember original was HEIC
        } else {
            if (existsSync(tempJpeg)) {
                try { unlinkSync(tempJpeg); } catch (e) {}
            }
            const errMsg = sharpError && sharpError.message ? sharpError.message : 'unknown error';
            throw new Error(`Cannot process image (${errMsg}). If this is HEIC, install libheif-examples (Linux) or use macOS`);
        }
    }

    console.error(`[giil] Image: ${metadata.width}x${metadata.height}, ${metadata.format || originalFormat || 'unknown'}`);

    // Use current time if no EXIF date
    if (!captureDate) {
        captureDate = new Date();
    }

    // v3 behavior: Only process if explicitly requested
    let processedBuffer;
    let outputExt;

    if (needsProcessing) {
        // Apply Sharp processing when requested
        let pipeline = sharp(processableBuffer);

        if (convert === 'jpeg' || (optimize && !convert)) {
            // Convert to JPEG or optimize with MozJPEG
            pipeline = pipeline.jpeg({
                quality: quality,
                mozjpeg: optimize === true,
                chromaSubsampling: '4:2:0'
            });
            outputExt = 'jpg';
            console.error(`[giil] Processing: ${optimize ? 'MozJPEG optimization' : 'JPEG conversion'} (quality ${quality})`);
        } else if (convert === 'png') {
            pipeline = pipeline.png({ compressionLevel: 9 });
            outputExt = 'png';
            console.error('[giil] Processing: PNG conversion');
        } else if (convert === 'webp') {
            pipeline = pipeline.webp({ quality: quality });
            outputExt = 'webp';
            console.error(`[giil] Processing: WebP conversion (quality ${quality})`);
        }

        processedBuffer = await pipeline.toBuffer();
    } else {
        // v3 default: Preserve original bytes
        processedBuffer = processableBuffer;
        // Normalize 'jpeg' to 'jpg' for consistent extension naming
        outputExt = metadata.format === 'jpeg' ? 'jpg' : (metadata.format || 'jpg');
        console.error('[giil] Preserving original bytes (use --optimize for MozJPEG compression)');
    }

    // Generate filename with datetime (v3: use outputExt for format-aware filenames)
    const dateStr = formatDateForFilename(captureDate);
    const { filename, outputPath } = getUniqueFilename(outputDir, dateStr, index, outputExt);

    // Clean up temp downloaded file
    if (downloadedFilePath && existsSync(downloadedFilePath)) {
        try { unlinkSync(downloadedFilePath); } catch (e) {}
    }

    // Output based on mode (v3 JSON schema: includes schema_version, ok, platform)
    if (base64Output) {
        if (jsonOutput) {
            // v3 JSON format with schema_version, ok, platform
            const result = formatJsonSuccess({
                base64: processedBuffer.toString('base64'),
                datetime: formatDateForJson(captureDate),
                method: captureMethod,
                ...(index !== undefined && { item_index: index })
            });
            console.log(JSON.stringify(result));
        } else {
            console.log(processedBuffer.toString('base64'));
        }
        console.error(`[giil] Output: base64 (${(processedBuffer.length / 1024).toFixed(1)} KB)`);
    } else {
        writeFileSync(outputPath, processedBuffer);

        if (jsonOutput) {
            // v3 JSON format with schema_version, ok, platform
            const result = formatJsonSuccess({
                path: outputPath,
                datetime: formatDateForJson(captureDate),
                sourceUrl: sourceUrl || url,
                method: captureMethod,
                size: processedBuffer.length,
                width: metadata.width,
                height: metadata.height,
                ...(index !== undefined && { item_index: index })
            });
            console.log(JSON.stringify(result));
        } else {
            console.log(outputPath);
        }
        console.error(`[giil] Saved: ${outputPath} (${(processedBuffer.length / 1024).toFixed(1)} KB, ${captureMethod})`);
    }

    return { outputPath, captureDate, metadata };
}

// Capture a single photo from the current page state
// Uses pre-captured images from imageCapture if available
async function captureSinglePhoto(page, context, options, imageCapture = null) {
    const { outputDir, quality, base64Output, jsonOutput, debugMode, timeoutMs, index } = options;

    // Use pre-captured images or start fresh tracking
    let bestImageBuffer = null;
    let bestImageSize = 0;
    let bestImageUrl = null;
    const refreshCapture = () => {
        if (!imageCapture) return;
        bestImageBuffer = imageCapture.buffer;
        bestImageSize = imageCapture.size || 0;
        bestImageUrl = imageCapture.url;
    };
    refreshCapture();

    let finalBuffer = null;
    let captureMethod = 'unknown';
    let downloadedFilePath = null;
    let sourceUrl = bestImageUrl;

    // ========================================
    // STRATEGY 1: Click Download button
    // ========================================
    if (!options.skipDownloadButton) {
        console.error('[giil] Trying download button...');
        const downloadSelectors = [
            'button[aria-label="Download"]',
            'button[title="Download"]',
            'a[aria-label="Download"]',
            'a[title="Download"]',
            '[data-testid*="download"]',
            'button:has-text("Download")',
            'a:has-text("Download")',
            '.download-button',
            '[class*="download"]:not([class*="downloading"])',
        ];

        for (const sel of downloadSelectors) {
            try {
                const handle = await page.$(sel);
                if (!handle) continue;

                // Check if element is visible
                const isVisible = await handle.isVisible().catch(() => false);
                if (!isVisible) continue;

                const [download] = await Promise.all([
                    page.waitForEvent('download', { timeout: 10000 }),
                    handle.click({ timeout: 5000 })
                ]);

                if (download) {
                    const suggestedName = download.suggestedFilename() || 'icloud_download';
                    const safeName = basename(suggestedName).replace(/[^A-Za-z0-9._-]/g, '_');
                    downloadedFilePath = join(outputDir, `_temp_${Date.now()}_${safeName}`);
                    await download.saveAs(downloadedFilePath);
                    finalBuffer = readFileSync(downloadedFilePath);
                    captureMethod = 'download';
                    sourceUrl = download.url();
                    console.error(`[giil] Downloaded: ${suggestedName}`);
                    break;
                }
            } catch (e) {
                // Try next selector
            }
        }
    }

    // Refresh captured CDN image after any downloads/clicks
    refreshCapture();

    // ========================================
    // STRATEGY 2: Use intercepted CDN image
    // ========================================
    if (!finalBuffer && bestImageBuffer && bestImageSize > 10000) {
        // For Google Photos, try to download full-resolution using =s0 modifier
        if (bestImageUrl && bestImageUrl.includes('googleusercontent.com/')) {
            console.error('[giil] Google Photos detected, trying full-resolution download...');
            const fullResResult = await downloadGooglePhotosFullRes(bestImageUrl);
            if (fullResResult && fullResResult.buffer) {
                finalBuffer = fullResResult.buffer;
                captureMethod = 'url-extraction';
                sourceUrl = fullResResult.url;
                console.error(`[giil] Google Photos full-res: ${(finalBuffer.length / 1024).toFixed(1)} KB`);
            } else {
                // Fall back to captured preview
                finalBuffer = bestImageBuffer;
                captureMethod = 'network';
                sourceUrl = bestImageUrl;
                console.error(`[giil] Using Google Photos preview: ${(bestImageSize / 1024).toFixed(1)} KB`);
            }
        } else {
            // Standard CDN capture (iCloud, etc.)
            finalBuffer = bestImageBuffer;
            captureMethod = 'network';
            sourceUrl = bestImageUrl;
            console.error(`[giil] Captured from CDN: ${(bestImageSize / 1024).toFixed(1)} KB`);
        }
    }

    // ========================================
    // STRATEGY 3: Screenshot image element
    // ========================================
    if (!finalBuffer) {
        console.error('[giil] Trying element screenshot...');
        const imgSelectors = [
            // iCloud selectors
            'img[src*="cvws.icloud-content"]',
            'img[src*="icloud-content"]',
            // Google Photos selectors
            'img[src*="googleusercontent.com"]',
            'img[src*="lh3.googleusercontent"]',
            '[data-latest-bg]',
            '.RY3tic',
            // Generic selectors
            '.photo-viewer img',
            '.media-viewer img',
            '[data-testid="photo"] img',
            'img.photo',
            'main img',
            'picture img',
            'img[alt]:not([alt=""])',
            '[role="img"]'
        ];

        for (const selector of imgSelectors) {
            try {
                const imgElement = await page.$(selector);
                if (imgElement) {
                    const isVisible = await imgElement.isVisible().catch(() => false);
                    if (!isVisible) continue;

                    const box = await imgElement.boundingBox();
                    if (box && box.width > 100 && box.height > 100) {
                        finalBuffer = await imgElement.screenshot({ type: 'png' });
                        captureMethod = 'element-screenshot';
                        console.error(`[giil] Screenshot: ${selector}`);
                        break;
                    }
                }
            } catch (e) {}
        }
    }

    // ========================================
    // STRATEGY 4: Viewport screenshot (last resort)
    // ========================================
    if (!finalBuffer) {
        console.error('[giil] Taking viewport screenshot (fallback)...');
        finalBuffer = await page.screenshot({ type: 'png', fullPage: false });
        captureMethod = 'viewport-screenshot';
    }

    // Validate buffer size
    if (!finalBuffer || finalBuffer.length < 1000) {
        throw new Error('Failed to capture image - buffer too small or empty');
    }

    // Validate content (detect HTML error pages masquerading as images)
    // Skip validation for screenshots (they are always valid PNG)
    if (captureMethod !== 'element-screenshot' && captureMethod !== 'viewport-screenshot') {
        try {
            validateImageContent(finalBuffer, null, debugMode);
        } catch (validationError) {
            console.error(`[giil] Content validation failed: ${validationError.message}`);
            throw validationError;
        }
    }

    // Process and save (v3: pass optimize/convert flags)
    console.error('[giil] Processing image...');
    return await processAndSaveImage(finalBuffer, {
        outputDir,
        quality,
        base64Output,
        jsonOutput,
        captureMethod,
        sourceUrl,
        downloadedFilePath,
        index,
        optimize: optimizeMode,
        convert: convertFormat
    });
}

// Create a response handler for capturing images during page load
function createImageCaptureHandler(debugMode) {
    const capture = {
        buffer: null,
        size: 0,
        url: null,
        contentType: null,
        // For album mode: collect all unique Google Photos CDN base URLs
        gphotoUrls: new Set()
    };

    const handler = async (response) => {
        try {
            const respUrl = response.url();
            const contentType = (response.headers()['content-type'] || '').toLowerCase();

            // Platform-specific CDN detection
            const isIcloudCdn = respUrl.includes('cvws.icloud-content.com') ||
                               respUrl.includes('icloud-content.com');
            const isGooglePhotosCdn = respUrl.includes('lh3.googleusercontent.com/pw/') ||
                                      respUrl.includes('googleusercontent.com/');
            const isImage = contentType.startsWith('image/');
            const isPhotoFormat = contentType.includes('jpeg') ||
                                  contentType.includes('png') ||
                                  contentType.includes('heic') ||
                                  contentType.includes('heif') ||
                                  contentType.includes('webp');
            const urlLower = respUrl.toLowerCase();
            const hasImageExtension = /\.(jpe?g|png|heic|heif|webp)(\?|#|$)/.test(urlLower);

            // Match iCloud CDN, Google Photos CDN, or any image from known domains
            const isRelevantCdn = isIcloudCdn || isGooglePhotosCdn ||
                                  (respUrl.includes('.icloud.com') && (isImage || hasImageExtension));

            // For Google Photos album mode: collect all unique base URLs
            if (isGooglePhotosCdn && respUrl.includes('lh3.googleusercontent.com/pw/')) {
                const { baseUrl } = extractGooglePhotosBaseUrl(respUrl);
                capture.gphotoUrls.add(baseUrl);
                if (debugMode) {
                    console.error(`[giil:debug] Collected Google Photos URL: ${baseUrl.substring(0, 80)}...`);
                }
            }

            if (isRelevantCdn && (isPhotoFormat || hasImageExtension || isGooglePhotosCdn)) {
                const buffer = await response.body();
                if (buffer && buffer.length > capture.size) {
                    // Validate content before caching (v3.0+)
                    try {
                        const validation = validateMagicBytes(buffer);
                        if (validation.isHtml) {
                            if (debugMode) {
                                console.error(`[giil:debug] Rejected HTML content from: ${respUrl}`);
                            }
                            return; // Skip this response - it's an error page
                        }
                    } catch (e) {
                        // Validation failed, skip this buffer
                        return;
                    }

                    capture.buffer = buffer;
                    capture.size = buffer.length;
                    capture.url = respUrl;
                    capture.contentType = contentType;
                    if (debugMode) {
                        console.error(`[giil:debug] Captured: ${(buffer.length / 1024).toFixed(1)} KB, ${contentType}`);
                    }
                }
            }
        } catch (e) {
            // Response body might not be available
        }
    };

    return { capture, handler };
}

function resetImageCapture(capture) {
    if (!capture) return;
    capture.buffer = null;
    capture.size = 0;
    capture.url = null;
    capture.contentType = null;
}

// Main extraction function
async function extractImage() {
    verbose(`Platform detected: ${detectPlatform(url)}`);
    verbose('Launching Playwright (headless)');

    const browser = await chromium.launch({
        headless: true,
        args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-web-security'
        ]
    });

    const context = await browser.newContext({
        viewport: { width: 1920, height: 1080 },
        userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
        acceptDownloads: true
    });

    // Start tracing if requested
    let tracePath = null;
    if (traceMode) {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '').slice(0, 15);
        const traceDir = debugDir || outputDir || '.';
        tracePath = join(traceDir, `giil_trace_${timestamp}.zip`);
        verbose(`Playwright tracing enabled, will save to: ${tracePath}`);
        await context.tracing.start({ screenshots: true, snapshots: true, sources: true });
    }

    const page = await context.newPage();
    const timeoutMs = timeoutSec * 1000;
    const results = [];

    // Set up image capture handler BEFORE navigation
    const { capture: imageCapture, handler: responseHandler } = createImageCaptureHandler(debugMode);
    page.on('response', responseHandler);
    verbose('Network interceptor installed');

    try {
        // Navigate to page
        console.error(`[giil] Loading: ${url}`);
        await page.goto(url, {
            waitUntil: 'domcontentloaded',
            timeout: timeoutMs
        });

        // Dismiss common overlays (cookie banners, etc.)
        const dismissTexts = ['Accept', 'Allow', 'OK', 'Continue', 'Not Now', 'Close', 'Dismiss', 'Got it'];
        for (const text of dismissTexts) {
            try {
                const btn = page.getByRole('button', { name: text, exact: false });
                if (await btn.count() > 0) {
                    await btn.first().click({ timeout: 1500 }).catch(() => {});
                }
            } catch (e) {}
        }

        // Wait for page to settle (use user's timeout, capped at 30s for this step)
        const settleTimeout = Math.min(timeoutMs, 30000);
        await page.waitForLoadState('networkidle', { timeout: settleTimeout }).catch(() => {});
        await sleep(1000);
        verbose('Page load complete, network idle');

        // --print-url mode: extract and output URL, don't download
        if (printUrlMode) {
            const capturedUrl = imageCapture.url;
            const platform = detectPlatform(url);

            verbose(`Captured URL: ${capturedUrl || 'none'}`);

            if (capturedUrl) {
                if (jsonOutput) {
                    console.log(JSON.stringify({ url: capturedUrl, platform, sourceUrl: url }));
                } else {
                    console.log(capturedUrl);
                }
                process.exit(ExitCodes.SUCCESS);
            } else {
                console.error('[giil] No direct URL captured (page may require interaction)');
                process.exit(ExitCodes.CAPTURE_FAILURE);
            }
        }

        if (allMode) {
            // ========================================
            // ALL MODE: Download every photo in album
            // ========================================
            console.error('[giil] Album mode: finding all photos...');

            // Find thumbnail elements (platform-aware selectors)
            const thumbnailSelectors = [
                // Generic selectors
                '[data-testid*="thumbnail"]',
                '.thumbnail',
                '[class*="thumbnail"]',
                '[class*="Thumbnail"]',
                '.photo-grid img',
                '.album-grid img',
                '[role="listitem"] img',
                '.grid img',
                'figure img',
                // iCloud specific
                '.media-grid-item',
                '[class*="media-grid"]',
                '.asset-grid img',
                // Google Photos specific (v3.0+)
                '[data-latest-bg]',
                '.RY3tic',
                '[role="listitem"] a',
                'a[aria-label*="photo" i]',
                'c-wiz [role="img"]',
                '[style*="background-image"][tabindex]'
            ];

            let thumbnails = [];
            for (const sel of thumbnailSelectors) {
                const found = await page.$$(sel);
                if (found.length > thumbnails.length) {
                    thumbnails = found;
                    console.error(`[giil] Found ${found.length} items with: ${sel}`);
                }
            }

            if (thumbnails.length === 0) {
                // For Google Photos: try using collected CDN URLs as fallback
                if (currentPlatform === 'gphotos' && imageCapture.gphotoUrls.size > 0) {
                    const gphotoBaseUrls = Array.from(imageCapture.gphotoUrls);
                    console.error(`[giil] Using ${gphotoBaseUrls.length} collected Google Photos URLs...`);

                    for (let i = 0; i < gphotoBaseUrls.length; i++) {
                        try {
                            // Rate limiting between photos
                            if (i > 0) {
                                await sleep(ALBUM_DELAY_MS);
                            }

                            console.error(`\n[giil] Photo ${i + 1}/${gphotoBaseUrls.length}...`);
                            const fullResResult = await downloadGooglePhotosFullRes(gphotoBaseUrls[i]);

                            if (fullResResult && fullResResult.buffer) {
                                // Process and save the image
                                const result = await processAndSaveImage(fullResResult.buffer, {
                                    outputDir, quality, base64Output, jsonOutput,
                                    captureMethod: 'url-extraction',
                                    sourceUrl: fullResResult.url,
                                    downloadedFilePath: null,
                                    index: i + 1,
                                    optimize: optimizeMode,
                                    convert: convertFormat
                                });
                                results.push(result);
                            }
                        } catch (e) {
                            console.error(`[giil] Failed to process photo ${i + 1}: ${e.message}`);
                        }
                    }
                } else {
                    // Fallback: treat as single photo
                    console.error('[giil] No album thumbnails found, treating as single photo');
                    const result = await captureSinglePhoto(page, context, {
                        outputDir, quality, base64Output, jsonOutput, debugMode, timeoutMs
                    }, imageCapture);
                    results.push(result);
                }
            } else {
                console.error(`[giil] Processing ${thumbnails.length} photos...`);

                for (let i = 0; i < thumbnails.length; i++) {
                    try {
                        // Polite delay between photos (skip first to avoid initial delay)
                        if (i > 0) {
                            if (debugMode) {
                                console.error(`[giil:debug] Rate limiting: waiting ${ALBUM_DELAY_MS}ms...`);
                            }
                            await sleep(ALBUM_DELAY_MS);
                        }

                        console.error(`\n[giil] Photo ${i + 1}/${thumbnails.length}...`);

                        // Re-query thumbnails in case DOM changed
                        let currentThumbnails = [];
                        for (const sel of thumbnailSelectors) {
                            const found = await page.$$(sel);
                            if (found.length > currentThumbnails.length) {
                                currentThumbnails = found;
                            }
                        }

                        if (i >= currentThumbnails.length) {
                            console.error(`[giil] Thumbnail ${i} no longer exists, skipping`);
                            continue;
                        }

                        const thumb = currentThumbnails[i];

                        // Reset network capture for this photo
                        resetImageCapture(imageCapture);

                        // Click to open full-size view
                        await thumb.click({ timeout: 5000 });
                        await sleep(2000);

                        // Wait for full-size image to load
                        await page.waitForLoadState('networkidle', { timeout: 10000 }).catch(() => {});

                        // Capture this photo (use refreshed capture buffer for network fallback)
                        const result = await captureSinglePhoto(page, context, {
                            outputDir, quality, base64Output, jsonOutput, debugMode, timeoutMs,
                            index: i + 1,
                            skipDownloadButton: false
                        }, imageCapture);
                        results.push(result);

                        // Go back to album view
                        // Try close button first
                        const closeSelectors = [
                            'button[aria-label="Close"]',
                            'button[title="Close"]',
                            '[data-testid*="close"]',
                            '.close-button',
                            '[class*="close"]'
                        ];

                        let closed = false;
                        for (const closeSel of closeSelectors) {
                            try {
                                const closeBtn = await page.$(closeSel);
                                if (closeBtn && await closeBtn.isVisible()) {
                                    await closeBtn.click({ timeout: 2000 });
                                    closed = true;
                                    break;
                                }
                            } catch (e) {}
                        }

                        if (!closed) {
                            // Press Escape key
                            await page.keyboard.press('Escape');
                        }

                        await sleep(1000);

                    } catch (e) {
                        console.error(`[giil] Failed to process photo ${i + 1}: ${e.message}`);
                    }
                }
            }

            console.error(`\n[giil] Album complete: ${results.length} photos saved`);

        } else {
            // ========================================
            // SINGLE MODE: Download one photo
            // ========================================

            // Platform-specific handling for Google Drive
            if (currentPlatform === 'gdrive') {
                console.error('[giil] Google Drive detected, using dedicated capture...');

                // Check for auth issues first
                const authCheck = await checkGoogleDriveAuth(page);
                if (authCheck.needsAuth) {
                    const error = new Error(authCheck.reason);
                    error.exitCode = ExitCodes.AUTH_REQUIRED;
                    error.code = 'AUTH_REQUIRED';
                    throw error;
                }
                if (authCheck.reason && authCheck.reason.includes('FILE_NOT_FOUND')) {
                    const error = new Error(authCheck.reason);
                    error.exitCode = ExitCodes.NOT_FOUND;
                    error.code = 'NOT_FOUND';
                    throw error;
                }

                // Extract file ID and use dedicated capture
                const fileId = extractGoogleDriveFileId(url);
                if (!fileId) {
                    console.error('[giil] Could not extract Google Drive file ID, using generic capture');
                    const result = await captureSinglePhoto(page, context, {
                        outputDir, quality, base64Output, jsonOutput, debugMode, timeoutMs
                    }, imageCapture);
                    results.push(result);
                } else {
                    const gdriveResult = await captureGoogleDrive(page, fileId, debugMode);
                    if (gdriveResult && gdriveResult.bytes) {
                        // Process and save the captured image
                        const result = await processAndSaveImage(gdriveResult.bytes, {
                            outputDir, quality, base64Output, jsonOutput,
                            captureMethod: gdriveResult.method,
                            sourceUrl: gdriveResult.sourceUrl,
                            downloadedFilePath: null,
                            index: undefined,
                            optimize: optimizeMode,
                            convert: convertFormat
                        });
                        results.push(result);
                    } else {
                        // Fallback to generic capture if Google Drive-specific failed
                        console.error('[giil] Google Drive capture failed, trying generic strategies...');
                        const result = await captureSinglePhoto(page, context, {
                            outputDir, quality, base64Output, jsonOutput, debugMode, timeoutMs
                        }, imageCapture);
                        results.push(result);
                    }
                }
            } else {
                // Generic capture for iCloud, Google Photos, Dropbox, etc.
                const result = await captureSinglePhoto(page, context, {
                    outputDir, quality, base64Output, jsonOutput, debugMode, timeoutMs
                }, imageCapture);
                results.push(result);
            }
        }

    } catch (error) {
        console.error(`[giil] Error: ${error.message}`);

        // Save debug artifacts
        if (debugMode) {
            try {
                const timestamp = Date.now();
                const debugScreenshot = join(outputDir, `giil_debug_${timestamp}.png`);
                await page.screenshot({ path: debugScreenshot, fullPage: true });
                console.error(`[giil] Debug screenshot: ${debugScreenshot}`);

                const debugHtml = join(outputDir, `giil_debug_${timestamp}.html`);
                const html = await page.content();
                writeFileSync(debugHtml, html);
                console.error(`[giil] Debug HTML: ${debugHtml}`);
            } catch (e) {}
        }

        throw error;
    } finally {
        page.off('response', responseHandler);

        // Save trace if enabled
        if (traceMode && tracePath) {
            try {
                await context.tracing.stop({ path: tracePath });
                console.error(`[giil] Trace saved: ${tracePath}`);
                console.error(`[giil] View trace: npx playwright show-trace ${tracePath}`);
            } catch (e) {
                console.error(`[giil] Failed to save trace: ${e.message}`);
            }
        }

        await browser.close();
    }
}

extractImage().catch(err => {
    console.error(`[giil] Fatal: ${err.message}`);

    // Determine error code and exit code
    let errorCode = 'CAPTURE_FAILURE';
    let exitCode = ExitCodes.CAPTURE_FAILURE;
    let remediation = null;

    // Use error's exitCode if available (set by validation functions)
    if (err.exitCode) {
        exitCode = err.exitCode;
        errorCode = err.code || 'CAPTURE_FAILURE';
        remediation = err.remediation || null;
    } else {
        // Map common error types to exit codes
        const msg = err.message.toLowerCase();
        if (msg.includes('timeout') || msg.includes('net::err') || msg.includes('dns')) {
            errorCode = 'NETWORK_ERROR';
            exitCode = ExitCodes.NETWORK_ERROR;
            remediation = 'Check your network connection and try again.';
        } else if (msg.includes('404') || msg.includes('not found') || msg.includes('expired')) {
            errorCode = 'NOT_FOUND';
            exitCode = ExitCodes.NOT_FOUND;
            remediation = 'The link may have expired or the file was deleted.';
        } else if (msg.includes('login') || msg.includes('auth') || msg.includes('password')) {
            errorCode = 'AUTH_REQUIRED';
            exitCode = ExitCodes.AUTH_REQUIRED;
            remediation = 'The file is not publicly shared. The owner must enable public access.';
        } else if (msg.includes('video') || msg.includes('unsupported')) {
            errorCode = 'UNSUPPORTED_TYPE';
            exitCode = ExitCodes.UNSUPPORTED_TYPE;
            remediation = 'giil only supports image files, not videos or documents.';
        }
    }

    // Output JSON error if --json mode is enabled
    if (jsonOutput) {
        const jsonError = formatJsonError(errorCode, err.message, remediation);
        console.log(JSON.stringify(jsonError));
    }

    process.exit(exitCode);
});
SCRIPT_EOF

    echo "$script_path"
}

# -----------------------------------------------------------------------------
# Argument Parsing
# -----------------------------------------------------------------------------

parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --base64)
                BASE64_OUTPUT=true
                shift
                ;;
            --json)
                JSON_OUTPUT=true
                shift
                ;;
            --all)
                ALL_MODE=true
                shift
                ;;
            --output)
                if [[ -z "${2:-}" || "$2" == --* ]]; then
                    log_error "--output requires a directory argument"
                    exit "$EXIT_USAGE_ERROR"
                fi
                OUTPUT_DIR="$2"
                shift 2
                ;;
            --quality)
                if [[ -z "${2:-}" || "$2" == --* ]]; then
                    log_error "--quality requires a number argument"
                    exit "$EXIT_USAGE_ERROR"
                fi
                QUALITY="$2"
                shift 2
                ;;
            --timeout)
                if [[ -z "${2:-}" || "$2" == --* ]]; then
                    log_error "--timeout requires a number argument"
                    exit "$EXIT_USAGE_ERROR"
                fi
                TIMEOUT="$2"
                shift 2
                ;;
            --update)
                FORCE_UPDATE=true
                shift
                ;;
            --debug)
                DEBUG_MODE=true
                shift
                ;;
            --verbose)
                VERBOSE=true
                DEBUG_MODE=true  # --verbose implies --debug
                shift
                ;;
            --trace)
                TRACE_MODE=true
                shift
                ;;
            --print-url)
                PRINT_URL=true
                shift
                ;;
            --debug-dir)
                if [[ -z "${2:-}" || "$2" == --* ]]; then
                    log_error "--debug-dir requires a directory argument"
                    exit "$EXIT_USAGE_ERROR"
                fi
                DEBUG_DIR="$2"
                shift 2
                ;;
            --optimize)
                OPTIMIZE_MODE=true
                shift
                ;;
            --convert)
                if [[ -z "${2:-}" || "$2" == --* ]]; then
                    log_error "--convert requires a format argument (jpeg, png, webp)"
                    exit "$EXIT_USAGE_ERROR"
                fi
                CONVERT_FORMAT="$2"
                shift 2
                ;;
            --version|-v)
                show_version
                ;;
            --help|-h)
                show_help
                ;;
            -*)
                log_error "Unknown option: $1"
                log_error "Run 'giil --help' for usage"
                exit "$EXIT_USAGE_ERROR"
                ;;
            *)
                if [[ -z "$URL" ]]; then
                    URL="$1"
                else
                    log_error "Multiple URLs not supported (use --all for albums)"
                    exit "$EXIT_USAGE_ERROR"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$URL" ]]; then
        show_quickstart
    fi

    # Validate quality
    if ! [[ "$QUALITY" =~ ^[0-9]+$ ]] || [[ "$QUALITY" -lt 1 ]] || [[ "$QUALITY" -gt 100 ]]; then
        log_error "Quality must be between 1 and 100"
        exit "$EXIT_USAGE_ERROR"
    fi

    # Validate timeout
    if ! [[ "$TIMEOUT" =~ ^[0-9]+$ ]] || [[ "$TIMEOUT" -lt 5 ]]; then
        log_error "Timeout must be at least 5 seconds"
        exit "$EXIT_USAGE_ERROR"
    fi

    # Validate --convert format if provided
    if [[ -n "$CONVERT_FORMAT" ]]; then
        case "$CONVERT_FORMAT" in
            jpeg|jpg|png|webp)
                # Normalize jpg to jpeg
                [[ "$CONVERT_FORMAT" == "jpg" ]] && CONVERT_FORMAT="jpeg"
                ;;
            *)
                log_error "Invalid --convert format: $CONVERT_FORMAT"
                log_error "Supported formats: jpeg, png, webp"
                exit "$EXIT_USAGE_ERROR"
                ;;
        esac
    fi

    # Warn about incompatible options
    if [[ "$BASE64_OUTPUT" == "true" && "$ALL_MODE" == "true" ]]; then
        log_warn "Using --base64 with --all will output multiple base64 strings"
    fi

    # Create output directory if needed
    if [[ -e "$OUTPUT_DIR" && ! -d "$OUTPUT_DIR" ]]; then
        log_error "--output path exists and is not a directory: $OUTPUT_DIR"
        exit "$EXIT_USAGE_ERROR"
    fi
    if [[ ! -d "$OUTPUT_DIR" ]]; then
        mkdir -p "$OUTPUT_DIR"
    fi

    # Convert OUTPUT_DIR to absolute path (critical: we cd to GIIL_HOME before running node)
    OUTPUT_DIR=$(cd "$OUTPUT_DIR" && pwd)

    # Normalize URL - support both formats
    # share.icloud.com/photos/XXX -> www.icloud.com/photos/#XXX
    if [[ "$URL" =~ share\.icloud\.com/photos/([A-Za-z0-9_+/=-]+) ]]; then
        local photo_id="${BASH_REMATCH[1]}"
        URL="https://www.icloud.com/photos/#${photo_id}"
        log_debug "Normalized URL: share -> www format"
    fi
}

# -----------------------------------------------------------------------------
# Dropbox Direct Download (v3.0+ - fast path, no Playwright)
# -----------------------------------------------------------------------------
# Dropbox provides full-resolution images via raw=1 parameter.
# This is FASTER and BETTER quality than Playwright (which only gets previews).

download_dropbox_direct() {
    # Normalize URL to direct download format
    local raw_url
    raw_url=$(normalize_dropbox_url "$URL")

    # --print-url mode: just output the URL and exit
    if [[ "$PRINT_URL" == "true" ]]; then
        if [[ "$JSON_OUTPUT" == "true" ]]; then
            echo "{\"url\":\"${raw_url}\",\"platform\":\"dropbox\"}"
        else
            echo "$raw_url"
        fi
        exit "$EXIT_SUCCESS"
    fi

    log_step "Dropbox detected - using fast direct download..."
    log_debug "Raw URL: $raw_url"

    # Generate output filename with timestamp
    local timestamp
    timestamp=$(date +%Y%m%d_%H%M%S)
    local output_path="${OUTPUT_DIR}/dropbox_${timestamp}.tmp"
    local final_path="${OUTPUT_DIR}/dropbox_${timestamp}.jpg"

    # Download with curl (follow redirects, get HTTP code)
    local http_code
    http_code=$(curl -sL -w "%{http_code}" -o "$output_path" "$raw_url")

    if [[ "$http_code" != "200" ]]; then
        log_error "Download failed with HTTP $http_code"
        rm -f "$output_path"
        if [[ "$http_code" == "404" ]]; then
            exit "$EXIT_NOT_FOUND"
        elif [[ "$http_code" == "401" || "$http_code" == "403" ]]; then
            exit "$EXIT_AUTH_REQUIRED"
        else
            exit "$EXIT_NETWORK_ERROR"
        fi
    fi

    # Validate content is actually an image (not HTML error page)
    local content_type
    content_type=$(file --mime-type -b "$output_path" 2>/dev/null || echo "unknown")

    if [[ "$content_type" == "text/html" || "$content_type" == "text/plain" ]]; then
        log_error "Received HTML instead of image."
        log_error "The link may be password-protected, expired, or deleted."
        rm -f "$output_path"
        exit "$EXIT_AUTH_REQUIRED"
    fi

    # Determine extension from content type
    local ext="jpg"
    case "$content_type" in
        image/png) ext="png" ;;
        image/gif) ext="gif" ;;
        image/webp) ext="webp" ;;
        image/heic|image/heif) ext="heic" ;;
    esac
    final_path="${OUTPUT_DIR}/dropbox_${timestamp}.${ext}"

    # Move to final path
    mv "$output_path" "$final_path"

    # Get file size for output
    local file_size
    file_size=$(stat -c%s "$final_path" 2>/dev/null || stat -f%z "$final_path" 2>/dev/null || echo "0")
    local size_kb=$((file_size / 1024))

    log_success "Downloaded: ${final_path} (${size_kb} KB, direct)"

    # Output based on mode
    if [[ "$JSON_OUTPUT" == "true" ]]; then
        # Get image dimensions using identify if available
        local width=0 height=0
        if command -v identify &> /dev/null; then
            local dims
            dims=$(identify -format "%w %h" "$final_path" 2>/dev/null || echo "0 0")
            width=$(echo "$dims" | cut -d' ' -f1)
            height=$(echo "$dims" | cut -d' ' -f2)
        fi

        cat << EOF
{"ok":true,"schema_version":"1","platform":"dropbox","path":"${final_path}","method":"direct","size":${file_size},"width":${width},"height":${height},"sourceUrl":"${raw_url}"}
EOF
    elif [[ "$BASE64_OUTPUT" == "true" ]]; then
        base64 < "$final_path"
    else
        echo "$final_path"
    fi

    exit "$EXIT_SUCCESS"
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    parse_args "$@"

    # Check for updates (opt-in, runs in background conceptually but blocks minimally)
    check_for_updates

    # Try to use gum for beautiful output (non-blocking)
    check_gum || true

    # Print styled banner
    print_banner

    if [[ "$DEBUG_MODE" == "true" ]]; then
        log_warn "Debug mode enabled"
    fi

    if [[ "$ALL_MODE" == "true" ]]; then
        log_info "Album mode: downloading all photos"
    fi

    # Detect platform and use appropriate strategy (v3.0+)
    local platform
    platform=$(detect_platform "$URL")
    log_debug "Detected platform: $platform"

    case "$platform" in
        dropbox)
            # Fast path: direct download, no Playwright needed
            download_dropbox_direct
            # download_dropbox_direct exits, so we never reach here
            ;;
        icloud|gphotos|gdrive|unknown)
            # Standard path: use Playwright extractor
            log_step "Checking dependencies..."
            ensure_node
            ensure_playwright

            local script_path
            script_path=$(create_extractor_script)

            if [[ "$ALL_MODE" == "true" ]]; then
                log_step "Extracting album..."
            else
                log_step "Extracting image..."
            fi

            log_debug "URL: $URL"
            log_debug "Output: $OUTPUT_DIR"
            log_debug "Quality: $QUALITY"
            log_debug "Timeout: ${TIMEOUT}s"
            log_debug "JSON output: $JSON_OUTPUT"
            log_debug "All mode: $ALL_MODE"
            log_debug "Optimize: $OPTIMIZE_MODE"
            log_debug "Convert: ${CONVERT_FORMAT:-none}"
            log_debug "Verbose: $VERBOSE"
            log_debug "Trace: $TRACE_MODE"
            log_debug "Print URL: $PRINT_URL"
            log_debug "Debug dir: ${DEBUG_DIR:-cwd}"

            cd "$GIIL_HOME"
            node "$script_path" "$URL" "$OUTPUT_DIR" "$QUALITY" "$BASE64_OUTPUT" "$DEBUG_MODE" "$TIMEOUT" "$JSON_OUTPUT" "$ALL_MODE" "$OPTIMIZE_MODE" "$CONVERT_FORMAT" "$VERBOSE" "$TRACE_MODE" "$PRINT_URL" "$DEBUG_DIR"
            ;;
    esac
}

main "$@"
