#!/usr/bin/env bash
#
# giil - Get iCloud Image Link (Hybrid Edition v2.1)
# Downloads images from iCloud photo shares with maximum reliability
#
# FEATURES:
#   - Primary: Click Download button (direct file acquisition)
#   - Fallback 1: Network interception (largest CDN image)
#   - Fallback 2: Element screenshot
#   - Fallback 3: Viewport screenshot
#   - EXIF datetime extraction for filenames
#   - Sharp + MozJPEG for superior compression
#   - HEIC/HEIF support with platform fallbacks
#   - Cookie/overlay auto-dismissal
#   - Album mode (--all) for downloading entire shared albums
#   - JSON output mode for scripting
#
# Usage:
#   giil <icloud-photo-url> [options]
#
# Options:
#   --base64         Output image as base64 to stdout
#   --json           Output JSON metadata instead of plain path
#   --all            Download all photos from shared album
#   --output DIR     Output directory (default: current)
#   --quality N      JPEG quality 1-100 (default: 85)
#   --update         Force update Playwright/dependencies
#   --debug          Save debug artifacts on failure
#   --timeout N      Page load timeout in seconds (default: 60)
#   --help           Show help message
#   --version        Show version
#

set -euo pipefail

VERSION="2.1.0"

# Colors for output (fallback when gum not available)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
DIM='\033[2m'
ITALIC='\033[3m'
NC='\033[0m'

# Gum availability flag
GUM_AVAILABLE=false

# Repository info for update checking
REPO_OWNER="Dicklesworthstone"
REPO_NAME="get_icloud_image_link"
VERSION_URL="https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/main/VERSION"

# -----------------------------------------------------------------------------
# Update checking (opt-in via GIIL_CHECK_UPDATES=1)
# -----------------------------------------------------------------------------

check_for_updates() {
    # Only check if explicitly enabled
    [[ -z "${GIIL_CHECK_UPDATES:-}" ]] && return 0

    # Only check once per day (cache result)
    # Note: GIIL_HOME is already set at script load time (line 353)
    local check_file="${GIIL_HOME}/.last_update_check"
    local one_day=86400

    mkdir -p "$GIIL_HOME" 2>/dev/null || true

    if [[ -f "$check_file" ]]; then
        local last_check
        last_check=$(cat "$check_file" 2>/dev/null || echo "0")
        local now
        now=$(date +%s)
        if (( now - last_check < one_day )); then
            return 0
        fi
    fi

    # Fetch remote version (with short timeout to avoid slowing down runs)
    local remote_version=""
    if command -v curl &> /dev/null; then
        remote_version=$(curl -fsSL --connect-timeout 2 --max-time 5 "$VERSION_URL" 2>/dev/null | tr -d '[:space:]') || true
    elif command -v wget &> /dev/null; then
        remote_version=$(wget -qO- --timeout=2 "$VERSION_URL" 2>/dev/null | tr -d '[:space:]') || true
    fi

    # Update check timestamp
    date +%s > "$check_file" 2>/dev/null || true

    # Compare versions
    if [[ -n "$remote_version" && "$remote_version" != "$VERSION" ]]; then
        # Robust version comparison (semver-aware when sort -V is available)
        if version_gt "$remote_version" "$VERSION"; then
            echo -e "${YELLOW}[giil]${NC} Update available: ${VERSION} ‚Üí ${remote_version}" >&2
            echo -e "${YELLOW}[giil]${NC} Run: curl -fsSL https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/main/install.sh | bash" >&2
        fi
    fi
}

# -----------------------------------------------------------------------------
# Gum (charmbracelet) integration for beautiful CLI
# -----------------------------------------------------------------------------

try_install_gum() {
    # Inline OS detection (detect_os is defined later)
    local os="unknown"
    case "$(uname -s)" in
        Darwin*) os="macos" ;;
        Linux*)  os="linux" ;;
    esac

    # Try to install gum quietly, don't fail if it doesn't work
    case "$os" in
        macos)
            if command -v brew &> /dev/null; then
                brew install gum &>/dev/null && return 0
            fi
            ;;
        linux)
            # Try common package managers
            if command -v apt-get &> /dev/null; then
                # Add charmbracelet repo and install
                (
                    sudo mkdir -p /etc/apt/keyrings 2>/dev/null
                    curl -fsSL https://repo.charm.sh/apt/gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/charm.gpg 2>/dev/null
                    echo "deb [signed-by=/etc/apt/keyrings/charm.gpg] https://repo.charm.sh/apt/ * *" | sudo tee /etc/apt/sources.list.d/charm.list >/dev/null
                    sudo apt-get update -qq && sudo apt-get install -y -qq gum
                ) &>/dev/null && return 0
            elif command -v dnf &> /dev/null; then
                (
                    echo '[charm]
name=Charm
baseurl=https://repo.charm.sh/yum/
enabled=1
gpgcheck=1
gpgkey=https://repo.charm.sh/yum/gpg.key' | sudo tee /etc/yum.repos.d/charm.repo >/dev/null
                    sudo dnf install -y gum
                ) &>/dev/null && return 0
            elif command -v pacman &> /dev/null; then
                sudo pacman -S --noconfirm gum &>/dev/null && return 0
            fi

            # Fallback: try downloading from GitHub releases
            local arch
            arch=$(uname -m)
            case "$arch" in
                x86_64) arch="amd64" ;;
                aarch64|arm64) arch="arm64" ;;
                *) return 1 ;;
            esac

            local tmp_dir
            tmp_dir=$(mktemp -d)
            local gum_version="0.14.5"
            local gum_url="https://github.com/charmbracelet/gum/releases/download/v${gum_version}/gum_${gum_version}_Linux_${arch}.tar.gz"

            (
                cd "$tmp_dir"
                curl -fsSL "$gum_url" -o gum.tar.gz
                tar -xzf gum.tar.gz
                sudo mv gum /usr/local/bin/gum 2>/dev/null || {
                    mkdir -p ~/.local/bin
                    mv gum ~/.local/bin/gum
                }
            ) &>/dev/null && rm -rf "$tmp_dir" && return 0

            rm -rf "$tmp_dir"
            ;;
    esac

    return 1
}

# Version comparison helper: returns 0 if $1 > $2
version_gt() {
    if command -v sort &> /dev/null && printf '%s\n' "$1" "$2" | sort -V >/dev/null 2>&1; then
        [[ "$(printf '%s\n' "$1" "$2" | sort -V | tail -n1)" == "$1" && "$1" != "$2" ]]
    else
        [[ "$1" > "$2" ]]
    fi
}

check_gum() {
    if command -v gum &> /dev/null; then
        GUM_AVAILABLE=true
        return 0
    fi

    # Only try to install gum if not in a CI environment and terminal is interactive
    if [[ -t 1 && -z "${CI:-}" && -z "${GIIL_NO_GUM:-}" ]]; then
        # Try to install gum silently
        if try_install_gum; then
            if [[ -x "${HOME}/.local/bin/gum" && ":$PATH:" != *":${HOME}/.local/bin:"* ]]; then
                export PATH="${HOME}/.local/bin:${PATH}"
            fi
            if command -v gum &> /dev/null; then
                GUM_AVAILABLE=true
                return 0
            fi
        fi
    fi

    return 1
}

# -----------------------------------------------------------------------------
# Styled output functions (use gum if available, fallback to ANSI)
# -----------------------------------------------------------------------------

# Print styled header/banner
print_banner() {
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style \
            --border double \
            --border-foreground 212 \
            --padding "0 2" \
            --margin "1 0" \
            --bold \
            "üçé giil v${VERSION}" \
            "Get iCloud Image Link"
    else
        echo -e "\n${BOLD}${MAGENTA}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}" >&2
        echo -e "${BOLD}${MAGENTA}‚ïë${NC}  ${BOLD}üçé giil v${VERSION}${NC}                    ${BOLD}${MAGENTA}‚ïë${NC}" >&2
        echo -e "${BOLD}${MAGENTA}‚ïë${NC}  ${DIM}Get iCloud Image Link${NC}             ${BOLD}${MAGENTA}‚ïë${NC}" >&2
        echo -e "${BOLD}${MAGENTA}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}\n" >&2
    fi
}

# Show quick start guide optimized for coding agents
show_quickstart() {
    # Initialize gum first
    check_gum || true

    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        # Beautiful gum-styled output
        gum style \
            --border rounded \
            --border-foreground 212 \
            --padding "1 2" \
            --margin "1" \
            --bold \
            "üçé giil v${VERSION} ‚Äî Get iCloud Image Link"

        echo ""

        gum style --foreground 214 --bold "SYNOPSIS"
        echo "  giil <URL> [OPTIONS]"
        echo ""

        gum style --foreground 214 --bold "QUICK EXAMPLES"
        gum style --foreground 39 "  # Download single photo ‚Üí stdout: filepath"
        echo "  giil \"https://share.icloud.com/photos/ABC123\""
        echo ""
        gum style --foreground 39 "  # Download with JSON metadata ‚Üí stdout: JSON"
        echo "  giil \"https://share.icloud.com/photos/ABC123\" --json"
        echo ""
        gum style --foreground 39 "  # Download album (all photos)"
        echo "  giil \"https://share.icloud.com/photos/ABC123\" --all --output ./album"
        echo ""
        gum style --foreground 39 "  # Get base64 for embedding"
        echo "  giil \"https://share.icloud.com/photos/ABC123\" --base64"
        echo ""

        gum style --foreground 214 --bold "OPTIONS"
        gum style --faint "  --output DIR     Save to directory (default: .)"
        gum style --faint "  --quality N      JPEG quality 1-100 (default: 85)"
        gum style --faint "  --json           Output: {path,datetime,sourceUrl,method,size,width,height}"
        gum style --faint "  --base64         Output: base64-encoded JPEG"
        gum style --faint "  --all            Download ALL photos from shared album"
        gum style --faint "  --timeout N      Page load timeout seconds (default: 60)"
        gum style --faint "  --debug          Save debug artifacts on failure"
        gum style --faint "  --help           Full documentation"
        echo ""

        gum style --foreground 214 --bold "OUTPUT FORMAT (for agents)"
        gum style --foreground 82 "  stdout:"
        gum style --faint "    Default:  /path/to/icloud_YYYYMMDD_HHMMSS.jpg"
        gum style --faint "    --json:   {\"path\":\"...\",\"datetime\":\"ISO8601\",\"method\":\"network|download\",...}"
        gum style --faint "    --base64: /9j/4AAQSkZJRg... (raw base64, no wrapper)"
        gum style --foreground 208 "  stderr:"
        gum style --faint "    Progress messages, errors (parseable: [giil] prefix)"
        echo ""

        gum style --foreground 214 --bold "CAPTURE METHODS (in priority order)"
        gum style --faint "  1. download        Click Download button (original file)"
        gum style --faint "  2. network         Intercept CDN response (full-res)"
        gum style --faint "  3. element-screenshot   Screenshot <img> element"
        gum style --faint "  4. viewport-screenshot  Screenshot viewport (fallback)"
        echo ""

        gum style --foreground 214 --bold "URL FORMATS (both work)"
        gum style --faint "  https://share.icloud.com/photos/<ID>"
        gum style --faint "  https://www.icloud.com/photos/#<ID>"
        echo ""

        gum style --foreground 245 --italic "First run installs Playwright+Chromium (~200MB, cached in ~/.cache/giil)"

    else
        # Fallback ANSI-styled output
        echo ""
        echo -e "${BOLD}${MAGENTA}‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ${NC}"
        echo -e "${BOLD}${MAGENTA}‚îÇ${NC}  üçé ${BOLD}giil v${VERSION}${NC} ‚Äî Get iCloud Image Link                        ${BOLD}${MAGENTA}‚îÇ${NC}"
        echo -e "${BOLD}${MAGENTA}‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ${NC}"
        echo ""
        echo -e "${BOLD}${YELLOW}SYNOPSIS${NC}"
        echo "  giil <URL> [OPTIONS]"
        echo ""
        echo -e "${BOLD}${YELLOW}QUICK EXAMPLES${NC}"
        echo -e "  ${CYAN}# Download single photo ‚Üí stdout: filepath${NC}"
        echo "  giil \"https://share.icloud.com/photos/ABC123\""
        echo ""
        echo -e "  ${CYAN}# Download with JSON metadata ‚Üí stdout: JSON${NC}"
        echo "  giil \"https://share.icloud.com/photos/ABC123\" --json"
        echo ""
        echo -e "  ${CYAN}# Download album (all photos)${NC}"
        echo "  giil \"https://share.icloud.com/photos/ABC123\" --all --output ./album"
        echo ""
        echo -e "  ${CYAN}# Get base64 for embedding${NC}"
        echo "  giil \"https://share.icloud.com/photos/ABC123\" --base64"
        echo ""
        echo -e "${BOLD}${YELLOW}OPTIONS${NC}"
        echo -e "  ${DIM}--output DIR     Save to directory (default: .)${NC}"
        echo -e "  ${DIM}--quality N      JPEG quality 1-100 (default: 85)${NC}"
        echo -e "  ${DIM}--json           Output: {path,datetime,sourceUrl,method,size,width,height}${NC}"
        echo -e "  ${DIM}--base64         Output: base64-encoded JPEG${NC}"
        echo -e "  ${DIM}--all            Download ALL photos from shared album${NC}"
        echo -e "  ${DIM}--timeout N      Page load timeout seconds (default: 60)${NC}"
        echo -e "  ${DIM}--debug          Save debug artifacts on failure${NC}"
        echo -e "  ${DIM}--help           Full documentation${NC}"
        echo ""
        echo -e "${BOLD}${YELLOW}OUTPUT FORMAT (for agents)${NC}"
        echo -e "  ${GREEN}stdout:${NC}"
        echo -e "    ${DIM}Default:  /path/to/icloud_YYYYMMDD_HHMMSS.jpg${NC}"
        echo -e "    ${DIM}--json:   {\"path\":\"...\",\"datetime\":\"ISO8601\",\"method\":\"network|download\",...}${NC}"
        echo -e "    ${DIM}--base64: /9j/4AAQSkZJRg... (raw base64, no wrapper)${NC}"
        echo -e "  ${YELLOW}stderr:${NC}"
        echo -e "    ${DIM}Progress messages, errors (parseable: [giil] prefix)${NC}"
        echo ""
        echo -e "${BOLD}${YELLOW}CAPTURE METHODS${NC} ${DIM}(in priority order)${NC}"
        echo -e "  ${DIM}1. download           Click Download button (original file)${NC}"
        echo -e "  ${DIM}2. network            Intercept CDN response (full-res)${NC}"
        echo -e "  ${DIM}3. element-screenshot Screenshot <img> element${NC}"
        echo -e "  ${DIM}4. viewport-screenshot Screenshot viewport (fallback)${NC}"
        echo ""
        echo -e "${BOLD}${YELLOW}URL FORMATS${NC} ${DIM}(both work)${NC}"
        echo -e "  ${DIM}https://share.icloud.com/photos/<ID>${NC}"
        echo -e "  ${DIM}https://www.icloud.com/photos/#<ID>${NC}"
        echo ""
        echo -e "${DIM}${ITALIC}First run installs Playwright+Chromium (~200MB, cached in ~/.cache/giil)${NC}"
    fi

    exit 0
}

# Default values
BASE64_OUTPUT=false
JSON_OUTPUT=false
ALL_MODE=false
OUTPUT_DIR="."
QUALITY=85
FORCE_UPDATE=false
DEBUG_MODE=false
TIMEOUT=60
URL=""

# XDG-compliant cache directory
CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
GIIL_HOME="${GIIL_HOME:-$CACHE_HOME/giil}"
PLAYWRIGHT_BROWSERS_PATH="${PLAYWRIGHT_BROWSERS_PATH:-$GIIL_HOME/ms-playwright}"

# -----------------------------------------------------------------------------
# Logging functions (with gum integration)
# -----------------------------------------------------------------------------

log_info() {
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum log --level info "$1" >&2
    else
        echo -e "${GREEN}[giil]${NC} $1" >&2
    fi
}

log_warn() {
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum log --level warn "$1" >&2
    else
        echo -e "${YELLOW}[giil]${NC} $1" >&2
    fi
}

log_error() {
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum log --level error "$1" >&2
    else
        echo -e "${RED}[giil]${NC} $1" >&2
    fi
}

log_step() {
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 39 "‚Üí $1" >&2
    else
        echo -e "${BLUE}[giil]${NC} $1" >&2
    fi
}

log_debug() {
    if [[ "$DEBUG_MODE" == "true" ]]; then
        if [[ "$GUM_AVAILABLE" == "true" ]]; then
            gum log --level debug "$1" >&2
        else
            echo -e "${CYAN}[giil:debug]${NC} $1" >&2
        fi
    fi
}

log_success() {
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 82 "‚úì $1" >&2
    else
        echo -e "${GREEN}‚úì${NC} $1" >&2
    fi
}

# -----------------------------------------------------------------------------
# Help and version
# -----------------------------------------------------------------------------

show_help() {
    cat << 'EOF'
giil - Get iCloud Image Link (Hybrid Edition v2.1)
Downloads images from iCloud photo shares with maximum reliability

Usage:
  giil <icloud-photo-url> [options]

Options:
  --base64         Output image as base64 text instead of saving file
  --json           Output JSON with path, datetime, sourceUrl, captureMethod
  --all            Download ALL photos from a shared album (iterates thumbnails)
  --output DIR     Output directory (default: current directory)
  --quality N      JPEG quality 1-100 (default: 85)
  --update         Force update Playwright and dependencies
  --debug          Enable debug mode with extra logging and artifacts
  --timeout N      Page load timeout in seconds (default: 60)
  --version        Show version information
  --help           Show this help message

Supported URL formats:
  https://share.icloud.com/photos/<id>
  https://www.icloud.com/photos/#<id>

Capture Strategy (in order of preference):
  1. Click Download button (highest quality, original file)
  2. Intercept CDN response (full-resolution image)
  3. Screenshot image element
  4. Screenshot viewport (last resort)

Output Modes:
  Default:   Prints file path to stdout
  --json:    {"path": "...", "datetime": "...", "sourceUrl": "...", "method": "..."}
  --base64:  Prints base64-encoded JPEG to stdout
  --all:     Downloads all images, outputs one path/JSON per line

Examples:
  # Download single photo
  giil "https://share.icloud.com/photos/02cD9okNHvVd-uuDnPCH3ZEEA"

  # Download to specific directory with lower quality
  giil "https://www.icloud.com/photos/#02cD9okNHvVd" --output ~/Downloads --quality 70

  # Get JSON output for scripting
  giil "https://share.icloud.com/photos/xxx" --json

  # Download entire shared album
  giil "https://share.icloud.com/photos/xxx" --all --output ~/album

EOF
    exit 0
}

show_version() {
    echo "giil version ${VERSION} (Hybrid Edition)"
    exit 0
}

# -----------------------------------------------------------------------------
# OS Detection
# -----------------------------------------------------------------------------

detect_os() {
    case "$(uname -s)" in
        Darwin*) echo "macos" ;;
        Linux*)  echo "linux" ;;
        *)       echo "unknown" ;;
    esac
}

# -----------------------------------------------------------------------------
# Dependency Management
# -----------------------------------------------------------------------------

install_node_macos() {
    if command -v brew &> /dev/null; then
        log_info "Installing Node.js via Homebrew..."
        brew install node
    else
        log_error "Homebrew not found. Please install Node.js manually:"
        log_error "  https://nodejs.org/ or 'brew install node'"
        exit 1
    fi
}

install_node_linux() {
    if command -v apt-get &> /dev/null; then
        log_info "Installing Node.js via apt..."
        sudo apt-get update
        sudo apt-get install -y nodejs npm
    elif command -v dnf &> /dev/null; then
        log_info "Installing Node.js via dnf..."
        sudo dnf install -y nodejs npm
    elif command -v yum &> /dev/null; then
        log_info "Installing Node.js via yum..."
        sudo yum install -y nodejs npm
    elif command -v pacman &> /dev/null; then
        log_info "Installing Node.js via pacman..."
        sudo pacman -S --noconfirm nodejs npm
    else
        log_error "Could not detect package manager. Please install Node.js manually:"
        log_error "  https://nodejs.org/"
        exit 1
    fi
}

ensure_node() {
    if ! command -v node &> /dev/null; then
        log_warn "Node.js not found. Installing..."
        local os
        os=$(detect_os)
        case "$os" in
            macos) install_node_macos ;;
            linux) install_node_linux ;;
            *)
                log_error "Unsupported OS. Please install Node.js manually."
                exit 1
                ;;
        esac
    fi

    local node_version
    node_version=$(node --version | sed 's/v//' | cut -d. -f1)
    if [[ "$node_version" -lt 18 ]]; then
        log_warn "Node.js v18+ recommended. Current: $(node --version)"
    fi

    log_debug "Node.js $(node --version)"
}

ensure_playwright() {
    local package_json="${GIIL_HOME}/package.json"
    local lock_file="${GIIL_HOME}/.installed"

    mkdir -p "$GIIL_HOME"

    # Check if we need to install or update
    local needs_install=false
    if [[ ! -f "$lock_file" ]] || [[ ! -d "${GIIL_HOME}/node_modules/playwright" ]]; then
        needs_install=true
    fi
    if [[ "$FORCE_UPDATE" == "true" ]]; then
        needs_install=true
        log_info "Forcing dependency update..."
        rm -f "$lock_file"
    fi

    if [[ "$needs_install" == "true" ]]; then
        # Show prominent first-run message
        echo "" >&2
        if [[ "$GUM_AVAILABLE" == "true" ]]; then
            gum style \
                --foreground 212 \
                --border rounded \
                --border-foreground 212 \
                --padding "0 2" \
                --bold \
                "‚è≥ INITIAL SETUP ‚Äî Please be patient!" \
                "" \
                "Installing Playwright + Chromium (~200MB)" \
                "This only happens once, then it's cached." >&2
        else
            echo -e "${BOLD}${YELLOW}‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ${NC}" >&2
            echo -e "${BOLD}${YELLOW}‚îÇ${NC}  ‚è≥ ${BOLD}INITIAL SETUP ‚Äî Please be patient!${NC}          ${BOLD}${YELLOW}‚îÇ${NC}" >&2
            echo -e "${BOLD}${YELLOW}‚îÇ${NC}                                                 ${BOLD}${YELLOW}‚îÇ${NC}" >&2
            echo -e "${BOLD}${YELLOW}‚îÇ${NC}  Installing Playwright + Chromium (~200MB)      ${BOLD}${YELLOW}‚îÇ${NC}" >&2
            echo -e "${BOLD}${YELLOW}‚îÇ${NC}  This only happens once, then it's cached.      ${BOLD}${YELLOW}‚îÇ${NC}" >&2
            echo -e "${BOLD}${YELLOW}‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ${NC}" >&2
        fi
        echo "" >&2

        # Create package.json with all dependencies
        cat > "$package_json" << 'PACKAGE_EOF'
{
  "name": "giil-runtime",
  "version": "2.1.0",
  "private": true,
  "type": "module",
  "dependencies": {
    "playwright": "1.40.0",
    "sharp": "0.33.0",
    "exifr": "7.1.3"
  }
}
PACKAGE_EOF

        cd "$GIIL_HOME"
        log_step "Installing npm packages..."
        npm install --silent --no-fund --no-audit --include=optional 2>/dev/null || \
            npm install --no-fund --no-audit --include=optional

        # Verify sharp runtime is usable; install platform-specific prebuilds if needed.
        if ! node -e "require('sharp')" >/dev/null 2>&1; then
            log_warn "Sharp runtime missing; attempting platform-specific install..."
            local os
            os=$(detect_os)
            local arch
            arch=$(uname -m)
            local sharp_pkg=""
            local vips_pkg=""
            local sharp_pkg_version=""
            local vips_pkg_version=""

            case "$os" in
                linux)
                    case "$arch" in
                        x86_64|amd64)
                            sharp_pkg="@img/sharp-linux-x64"
                            vips_pkg="@img/sharp-libvips-linux-x64"
                            ;;
                        aarch64|arm64)
                            sharp_pkg="@img/sharp-linux-arm64"
                            vips_pkg="@img/sharp-libvips-linux-arm64"
                            ;;
                    esac
                    ;;
                macos)
                    case "$arch" in
                        x86_64|amd64)
                            sharp_pkg="@img/sharp-darwin-x64"
                            vips_pkg="@img/sharp-libvips-darwin-x64"
                            ;;
                        arm64)
                            sharp_pkg="@img/sharp-darwin-arm64"
                            vips_pkg="@img/sharp-libvips-darwin-arm64"
                            ;;
                    esac
                    ;;
            esac

            if [[ -n "$sharp_pkg" && -n "$vips_pkg" ]]; then
                sharp_pkg_version=$(node -p "require('./node_modules/sharp/package.json').optionalDependencies['${sharp_pkg}'] || ''" 2>/dev/null || echo "")
                vips_pkg_version=$(node -p "require('./node_modules/sharp/package.json').optionalDependencies['${vips_pkg}'] || ''" 2>/dev/null || echo "")

                if [[ -n "$sharp_pkg_version" && -n "$vips_pkg_version" ]]; then
                    npm install --no-fund --no-audit --force "${sharp_pkg}@${sharp_pkg_version}" "${vips_pkg}@${vips_pkg_version}"
                else
                    npm install --no-fund --no-audit --force "$sharp_pkg" "$vips_pkg"
                fi
            else
                log_warn "No prebuilt sharp packages available for ${os}/${arch}"
            fi

            if ! node -e "require('sharp')" >/dev/null 2>&1; then
                log_error "Sharp failed to install. Try reinstalling dependencies or set GIIL_HOME to a writable path."
                exit 1
            fi
        fi

        log_step "Installing Chromium browser..."
        export PLAYWRIGHT_BROWSERS_PATH
        npx playwright install chromium 2>&1 | sed '/^$/d' || {
            local os
            os=$(detect_os)
            if [[ "$os" == "linux" ]]; then
                log_warn "Trying with system dependencies (may require sudo)..."
                npx playwright install --with-deps chromium 2>&1 | sed '/^$/d' || {
                    log_error "Failed to install Chromium. Try manually:"
                    log_error "  npx playwright install --with-deps chromium"
                    exit 1
                }
            else
                log_error "Failed to install Chromium. Try manually:"
                log_error "  npx playwright install chromium"
                exit 1
            fi
        }

        touch "$lock_file"
        log_info "Setup complete!"
    fi

    export PLAYWRIGHT_BROWSERS_PATH
}

# -----------------------------------------------------------------------------
# Node.js Extractor Script (Hybrid approach with --all and --json support)
# -----------------------------------------------------------------------------

create_extractor_script() {
    local script_path="${GIIL_HOME}/extractor.mjs"

    cat > "$script_path" << 'SCRIPT_EOF'
import { chromium } from 'playwright';
import sharp from 'sharp';
import exifr from 'exifr';
import { writeFileSync, readFileSync, existsSync, unlinkSync } from 'fs';
import { join, basename } from 'path';
import { execFileSync } from 'child_process';

// Parse arguments
const args = process.argv.slice(2);
const url = args[0];
const outputDir = args[1] || '.';
const quality = parseInt(args[2] || '85', 10);
const base64Output = args[3] === 'true';
const debugMode = args[4] === 'true';
const timeoutSec = parseInt(args[5] || '60', 10);
const jsonOutput = args[6] === 'true';
const allMode = args[7] === 'true';

if (!url) {
    console.error('Usage: node extractor.mjs <url> <outputDir> <quality> <base64> <debug> <timeout> <json> <all>');
    process.exit(1);
}

// Helper: sleep
const sleep = (ms) => new Promise(r => setTimeout(r, ms));

// Helper: format date for filename (YYYYMMDD_HHMMSS)
function formatDateForFilename(date) {
    const pad = (n) => String(n).padStart(2, '0');
    return `${date.getFullYear()}${pad(date.getMonth() + 1)}${pad(date.getDate())}_` +
           `${pad(date.getHours())}${pad(date.getMinutes())}${pad(date.getSeconds())}`;
}

// Helper: format date for JSON (ISO 8601)
function formatDateForJson(date) {
    return date.toISOString();
}

// Helper: extract EXIF datetime from buffer
async function getExifDateTime(buffer) {
    try {
        const exif = await exifr.parse(buffer, {
            pick: ['DateTimeOriginal', 'CreateDate', 'ModifyDate', 'DateTimeDigitized']
        });
        if (exif) {
            const dt = exif.DateTimeOriginal || exif.CreateDate ||
                       exif.DateTimeDigitized || exif.ModifyDate;
            if (dt instanceof Date && !isNaN(dt.getTime())) {
                return dt;
            }
        }
    } catch (e) {
        // EXIF parsing failed, will use current time
    }
    return null;
}

// Helper: try HEIC conversion with system tools (synchronous)
function convertHeicWithSystemTools(inputPath, outputPath) {
    const platform = process.platform;
    try {
        if (platform === 'darwin') {
            execFileSync('sips', ['-s', 'format', 'jpeg', inputPath, '--out', outputPath], { stdio: 'ignore' });
            return true;
        } else if (platform === 'linux') {
            execFileSync('heif-convert', [inputPath, outputPath], { stdio: 'ignore' });
            return true;
        }
    } catch (e) {
        // System tool not available or failed
    }
    return false;
}

// Helper: generate unique filename with counter if needed
function getUniqueFilename(outputDir, dateStr, index = null) {
    const suffix = index !== null ? `_${String(index).padStart(3, '0')}` : '';
    let filename = `icloud_${dateStr}${suffix}.jpg`;
    let outputPath = join(outputDir, filename);

    // If file exists, add counter
    let counter = 1;
    while (existsSync(outputPath)) {
        filename = `icloud_${dateStr}${suffix}_${counter}.jpg`;
        outputPath = join(outputDir, filename);
        counter++;
    }
    return { filename, outputPath };
}

// Process a single image buffer and save/output it
async function processAndSaveImage(buffer, options) {
    const {
        outputDir, quality, base64Output, jsonOutput,
        captureMethod, sourceUrl, downloadedFilePath, index
    } = options;

    // Try to get EXIF datetime
    let captureDate = await getExifDateTime(buffer);

    // Handle HEIC/HEIF conversion if needed
    let processableBuffer = buffer;
    try {
        await sharp(buffer).metadata();
    } catch (sharpError) {
        const tempJpeg = join(outputDir, `_temp_converted_${Date.now()}.jpg`);
        let didConvert = false;
        let tempInput = null;

        if (downloadedFilePath && existsSync(downloadedFilePath)) {
            didConvert = convertHeicWithSystemTools(downloadedFilePath, tempJpeg);
        } else {
            tempInput = join(outputDir, `_temp_input_${Date.now()}.heic`);
            try {
                writeFileSync(tempInput, buffer);
                didConvert = convertHeicWithSystemTools(tempInput, tempJpeg);
            } catch (e) {
                // Conversion attempt failed; handled below
            } finally {
                if (tempInput && existsSync(tempInput)) {
                    try { unlinkSync(tempInput); } catch (e) {}
                }
            }
        }

        if (didConvert && existsSync(tempJpeg)) {
            processableBuffer = readFileSync(tempJpeg);
            try { unlinkSync(tempJpeg); } catch (e) {}
            console.error('[giil] Converted HEIC using system tools');
        } else {
            if (existsSync(tempJpeg)) {
                try { unlinkSync(tempJpeg); } catch (e) {}
            }
            const errMsg = sharpError && sharpError.message ? sharpError.message : 'unknown error';
            throw new Error(`Cannot process image (${errMsg}). If this is HEIC, install libheif-examples (Linux) or use macOS`);
        }
    }

    // Get metadata
    const metadata = await sharp(processableBuffer).metadata();
    console.error(`[giil] Image: ${metadata.width}x${metadata.height}, ${metadata.format || 'unknown'}`);

    // Use current time if no EXIF date
    if (!captureDate) {
        captureDate = new Date();
    }

    // Convert to optimized JPEG
    const processedBuffer = await sharp(processableBuffer)
        .jpeg({
            quality: quality,
            mozjpeg: true,
            chromaSubsampling: '4:2:0'
        })
        .toBuffer();

    // Generate filename with datetime
    const dateStr = formatDateForFilename(captureDate);
    const { filename, outputPath } = getUniqueFilename(outputDir, dateStr, index);

    // Clean up temp downloaded file
    if (downloadedFilePath && existsSync(downloadedFilePath)) {
        try { unlinkSync(downloadedFilePath); } catch (e) {}
    }

    // Output based on mode
    if (base64Output) {
        const result = {
            base64: processedBuffer.toString('base64'),
            datetime: formatDateForJson(captureDate),
            method: captureMethod
        };
        if (jsonOutput) {
            console.log(JSON.stringify(result));
        } else {
            console.log(result.base64);
        }
        console.error(`[giil] Output: base64 (${(processedBuffer.length / 1024).toFixed(1)} KB)`);
    } else {
        writeFileSync(outputPath, processedBuffer);

        if (jsonOutput) {
            const result = {
                path: outputPath,
                datetime: formatDateForJson(captureDate),
                sourceUrl: sourceUrl || url,
                method: captureMethod,
                size: processedBuffer.length,
                width: metadata.width,
                height: metadata.height
            };
            console.log(JSON.stringify(result));
        } else {
            console.log(outputPath);
        }
        console.error(`[giil] Saved: ${outputPath} (${(processedBuffer.length / 1024).toFixed(1)} KB, ${captureMethod})`);
    }

    return { outputPath, captureDate, metadata };
}

// Capture a single photo from the current page state
// Uses pre-captured images from imageCapture if available
async function captureSinglePhoto(page, context, options, imageCapture = null) {
    const { outputDir, quality, base64Output, jsonOutput, debugMode, timeoutMs, index } = options;

    // Use pre-captured images or start fresh tracking
    let bestImageBuffer = null;
    let bestImageSize = 0;
    let bestImageUrl = null;
    const refreshCapture = () => {
        if (!imageCapture) return;
        bestImageBuffer = imageCapture.buffer;
        bestImageSize = imageCapture.size || 0;
        bestImageUrl = imageCapture.url;
    };
    refreshCapture();

    let finalBuffer = null;
    let captureMethod = 'unknown';
    let downloadedFilePath = null;
    let sourceUrl = bestImageUrl;

    // ========================================
    // STRATEGY 1: Click Download button
    // ========================================
    if (!options.skipDownloadButton) {
        console.error('[giil] Trying download button...');
        const downloadSelectors = [
            'button[aria-label="Download"]',
            'button[title="Download"]',
            'a[aria-label="Download"]',
            'a[title="Download"]',
            '[data-testid*="download"]',
            'button:has-text("Download")',
            'a:has-text("Download")',
            '.download-button',
            '[class*="download"]:not([class*="downloading"])',
        ];

        for (const sel of downloadSelectors) {
            try {
                const handle = await page.$(sel);
                if (!handle) continue;

                // Check if element is visible
                const isVisible = await handle.isVisible().catch(() => false);
                if (!isVisible) continue;

                const [download] = await Promise.all([
                    page.waitForEvent('download', { timeout: 10000 }),
                    handle.click({ timeout: 5000 })
                ]);

                if (download) {
                    const suggestedName = download.suggestedFilename() || 'icloud_download';
                    const safeName = basename(suggestedName).replace(/[^A-Za-z0-9._-]/g, '_');
                    downloadedFilePath = join(outputDir, `_temp_${Date.now()}_${safeName}`);
                    await download.saveAs(downloadedFilePath);
                    finalBuffer = readFileSync(downloadedFilePath);
                    captureMethod = 'download';
                    sourceUrl = download.url();
                    console.error(`[giil] Downloaded: ${suggestedName}`);
                    break;
                }
            } catch (e) {
                // Try next selector
            }
        }
    }

    // Refresh captured CDN image after any downloads/clicks
    refreshCapture();

    // ========================================
    // STRATEGY 2: Use intercepted CDN image
    // ========================================
    if (!finalBuffer && bestImageBuffer && bestImageSize > 10000) {
        finalBuffer = bestImageBuffer;
        captureMethod = 'network';
        sourceUrl = bestImageUrl;
        console.error(`[giil] Captured from CDN: ${(bestImageSize / 1024).toFixed(1)} KB`);
    }

    // ========================================
    // STRATEGY 3: Screenshot image element
    // ========================================
    if (!finalBuffer) {
        console.error('[giil] Trying element screenshot...');
        const imgSelectors = [
            'img[src*="cvws.icloud-content"]',
            'img[src*="icloud-content"]',
            '.photo-viewer img',
            '.media-viewer img',
            '[data-testid="photo"] img',
            'img.photo',
            'main img',
            'picture img',
            'img[alt]:not([alt=""])',
            '[role="img"]'
        ];

        for (const selector of imgSelectors) {
            try {
                const imgElement = await page.$(selector);
                if (imgElement) {
                    const isVisible = await imgElement.isVisible().catch(() => false);
                    if (!isVisible) continue;

                    const box = await imgElement.boundingBox();
                    if (box && box.width > 100 && box.height > 100) {
                        finalBuffer = await imgElement.screenshot({ type: 'png' });
                        captureMethod = 'element-screenshot';
                        console.error(`[giil] Screenshot: ${selector}`);
                        break;
                    }
                }
            } catch (e) {}
        }
    }

    // ========================================
    // STRATEGY 4: Viewport screenshot (last resort)
    // ========================================
    if (!finalBuffer) {
        console.error('[giil] Taking viewport screenshot (fallback)...');
        finalBuffer = await page.screenshot({ type: 'png', fullPage: false });
        captureMethod = 'viewport-screenshot';
    }

    // Validate buffer
    if (!finalBuffer || finalBuffer.length < 1000) {
        throw new Error('Failed to capture image - buffer too small or empty');
    }

    // Process and save
    console.error('[giil] Processing image...');
    return await processAndSaveImage(finalBuffer, {
        outputDir,
        quality,
        base64Output,
        jsonOutput,
        captureMethod,
        sourceUrl,
        downloadedFilePath,
        index
    });
}

// Create a response handler for capturing images during page load
function createImageCaptureHandler(debugMode) {
    const capture = {
        buffer: null,
        size: 0,
        url: null
    };

    const handler = async (response) => {
        try {
            const respUrl = response.url();
            const contentType = (response.headers()['content-type'] || '').toLowerCase();

            const isIcloudCdn = respUrl.includes('cvws.icloud-content.com') ||
                               respUrl.includes('icloud-content.com');
            const isImage = contentType.startsWith('image/');
            const isPhotoFormat = contentType.includes('jpeg') ||
                                  contentType.includes('png') ||
                                  contentType.includes('heic') ||
                                  contentType.includes('heif') ||
                                  contentType.includes('webp');
            const urlLower = respUrl.toLowerCase();
            const hasImageExtension = /\.(jpe?g|png|heic|heif|webp)(\?|#|$)/.test(urlLower);

            if ((isIcloudCdn || (respUrl.includes('.icloud.com') && (isImage || hasImageExtension))) &&
                (isPhotoFormat || hasImageExtension)) {
                const buffer = await response.body();
                if (buffer && buffer.length > capture.size) {
                    capture.buffer = buffer;
                    capture.size = buffer.length;
                    capture.url = respUrl;
                    if (debugMode) {
                        console.error(`[giil:debug] Captured: ${(buffer.length / 1024).toFixed(1)} KB, ${contentType}`);
                    }
                }
            }
        } catch (e) {
            // Response body might not be available
        }
    };

    return { capture, handler };
}

function resetImageCapture(capture) {
    if (!capture) return;
    capture.buffer = null;
    capture.size = 0;
    capture.url = null;
}

// Main extraction function
async function extractImage() {
    const browser = await chromium.launch({
        headless: true,
        args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-web-security'
        ]
    });

    const context = await browser.newContext({
        viewport: { width: 1920, height: 1080 },
        userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
        acceptDownloads: true
    });

    const page = await context.newPage();
    const timeoutMs = timeoutSec * 1000;
    const results = [];

    // Set up image capture handler BEFORE navigation
    const { capture: imageCapture, handler: responseHandler } = createImageCaptureHandler(debugMode);
    page.on('response', responseHandler);

    try {
        // Navigate to page
        console.error(`[giil] Loading: ${url}`);
        await page.goto(url, {
            waitUntil: 'domcontentloaded',
            timeout: timeoutMs
        });

        // Dismiss common overlays (cookie banners, etc.)
        const dismissTexts = ['Accept', 'Allow', 'OK', 'Continue', 'Not Now', 'Close', 'Dismiss', 'Got it'];
        for (const text of dismissTexts) {
            try {
                const btn = page.getByRole('button', { name: text, exact: false });
                if (await btn.count() > 0) {
                    await btn.first().click({ timeout: 1500 }).catch(() => {});
                }
            } catch (e) {}
        }

        // Wait for page to settle (use user's timeout, capped at 30s for this step)
        const settleTimeout = Math.min(timeoutMs, 30000);
        await page.waitForLoadState('networkidle', { timeout: settleTimeout }).catch(() => {});
        await sleep(1000);

        if (allMode) {
            // ========================================
            // ALL MODE: Download every photo in album
            // ========================================
            console.error('[giil] Album mode: finding all photos...');

            // Find thumbnail elements
            const thumbnailSelectors = [
                '[data-testid*="thumbnail"]',
                '.thumbnail',
                '[class*="thumbnail"]',
                '[class*="Thumbnail"]',
                '.photo-grid img',
                '.album-grid img',
                '[role="listitem"] img',
                '.grid img',
                'figure img',
                // iCloud specific
                '.media-grid-item',
                '[class*="media-grid"]',
                '.asset-grid img'
            ];

            let thumbnails = [];
            for (const sel of thumbnailSelectors) {
                const found = await page.$$(sel);
                if (found.length > thumbnails.length) {
                    thumbnails = found;
                    console.error(`[giil] Found ${found.length} items with: ${sel}`);
                }
            }

            if (thumbnails.length === 0) {
                // Try clicking on the first photo area and check if it's a single photo
                console.error('[giil] No album thumbnails found, treating as single photo');
                const result = await captureSinglePhoto(page, context, {
                    outputDir, quality, base64Output, jsonOutput, debugMode, timeoutMs
                }, imageCapture);
                results.push(result);
            } else {
                console.error(`[giil] Processing ${thumbnails.length} photos...`);

                for (let i = 0; i < thumbnails.length; i++) {
                    try {
                        console.error(`\n[giil] Photo ${i + 1}/${thumbnails.length}...`);

                        // Re-query thumbnails in case DOM changed
                        let currentThumbnails = [];
                        for (const sel of thumbnailSelectors) {
                            const found = await page.$$(sel);
                            if (found.length > currentThumbnails.length) {
                                currentThumbnails = found;
                            }
                        }

                        if (i >= currentThumbnails.length) {
                            console.error(`[giil] Thumbnail ${i} no longer exists, skipping`);
                            continue;
                        }

                        const thumb = currentThumbnails[i];

                        // Reset network capture for this photo
                        resetImageCapture(imageCapture);

                        // Click to open full-size view
                        await thumb.click({ timeout: 5000 });
                        await sleep(2000);

                        // Wait for full-size image to load
                        await page.waitForLoadState('networkidle', { timeout: 10000 }).catch(() => {});

                        // Capture this photo (use refreshed capture buffer for network fallback)
                        const result = await captureSinglePhoto(page, context, {
                            outputDir, quality, base64Output, jsonOutput, debugMode, timeoutMs,
                            index: i + 1,
                            skipDownloadButton: false
                        }, imageCapture);
                        results.push(result);

                        // Go back to album view
                        // Try close button first
                        const closeSelectors = [
                            'button[aria-label="Close"]',
                            'button[title="Close"]',
                            '[data-testid*="close"]',
                            '.close-button',
                            '[class*="close"]'
                        ];

                        let closed = false;
                        for (const closeSel of closeSelectors) {
                            try {
                                const closeBtn = await page.$(closeSel);
                                if (closeBtn && await closeBtn.isVisible()) {
                                    await closeBtn.click({ timeout: 2000 });
                                    closed = true;
                                    break;
                                }
                            } catch (e) {}
                        }

                        if (!closed) {
                            // Press Escape key
                            await page.keyboard.press('Escape');
                        }

                        await sleep(1000);

                    } catch (e) {
                        console.error(`[giil] Failed to process photo ${i + 1}: ${e.message}`);
                    }
                }
            }

            console.error(`\n[giil] Album complete: ${results.length} photos saved`);

        } else {
            // ========================================
            // SINGLE MODE: Download one photo
            // ========================================
            const result = await captureSinglePhoto(page, context, {
                outputDir, quality, base64Output, jsonOutput, debugMode, timeoutMs
            }, imageCapture);
            results.push(result);
        }

    } catch (error) {
        console.error(`[giil] Error: ${error.message}`);

        // Save debug artifacts
        if (debugMode) {
            try {
                const timestamp = Date.now();
                const debugScreenshot = join(outputDir, `giil_debug_${timestamp}.png`);
                await page.screenshot({ path: debugScreenshot, fullPage: true });
                console.error(`[giil] Debug screenshot: ${debugScreenshot}`);

                const debugHtml = join(outputDir, `giil_debug_${timestamp}.html`);
                const html = await page.content();
                writeFileSync(debugHtml, html);
                console.error(`[giil] Debug HTML: ${debugHtml}`);
            } catch (e) {}
        }

        throw error;
    } finally {
        page.off('response', responseHandler);
        await browser.close();
    }
}

extractImage().catch(err => {
    console.error(`[giil] Fatal: ${err.message}`);
    process.exit(1);
});
SCRIPT_EOF

    echo "$script_path"
}

# -----------------------------------------------------------------------------
# Argument Parsing
# -----------------------------------------------------------------------------

parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --base64)
                BASE64_OUTPUT=true
                shift
                ;;
            --json)
                JSON_OUTPUT=true
                shift
                ;;
            --all)
                ALL_MODE=true
                shift
                ;;
            --output)
                if [[ -z "${2:-}" || "$2" == --* ]]; then
                    log_error "--output requires a directory argument"
                    exit 1
                fi
                OUTPUT_DIR="$2"
                shift 2
                ;;
            --quality)
                if [[ -z "${2:-}" || "$2" == --* ]]; then
                    log_error "--quality requires a number argument"
                    exit 1
                fi
                QUALITY="$2"
                shift 2
                ;;
            --timeout)
                if [[ -z "${2:-}" || "$2" == --* ]]; then
                    log_error "--timeout requires a number argument"
                    exit 1
                fi
                TIMEOUT="$2"
                shift 2
                ;;
            --update)
                FORCE_UPDATE=true
                shift
                ;;
            --debug)
                DEBUG_MODE=true
                shift
                ;;
            --version|-v)
                show_version
                ;;
            --help|-h)
                show_help
                ;;
            -*)
                log_error "Unknown option: $1"
                log_error "Run 'giil --help' for usage"
                exit 1
                ;;
            *)
                if [[ -z "$URL" ]]; then
                    URL="$1"
                else
                    log_error "Multiple URLs not supported (use --all for albums)"
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$URL" ]]; then
        show_quickstart
    fi

    # Validate quality
    if ! [[ "$QUALITY" =~ ^[0-9]+$ ]] || [[ "$QUALITY" -lt 1 ]] || [[ "$QUALITY" -gt 100 ]]; then
        log_error "Quality must be between 1 and 100"
        exit 1
    fi

    # Validate timeout
    if ! [[ "$TIMEOUT" =~ ^[0-9]+$ ]] || [[ "$TIMEOUT" -lt 5 ]]; then
        log_error "Timeout must be at least 5 seconds"
        exit 1
    fi

    # Warn about incompatible options
    if [[ "$BASE64_OUTPUT" == "true" && "$ALL_MODE" == "true" ]]; then
        log_warn "Using --base64 with --all will output multiple base64 strings"
    fi

    # Create output directory if needed
    if [[ -e "$OUTPUT_DIR" && ! -d "$OUTPUT_DIR" ]]; then
        log_error "--output path exists and is not a directory: $OUTPUT_DIR"
        exit 1
    fi
    if [[ ! -d "$OUTPUT_DIR" ]]; then
        mkdir -p "$OUTPUT_DIR"
    fi

    # Convert OUTPUT_DIR to absolute path (critical: we cd to GIIL_HOME before running node)
    OUTPUT_DIR=$(cd "$OUTPUT_DIR" && pwd)

    # Normalize URL - support both formats
    # share.icloud.com/photos/XXX -> www.icloud.com/photos/#XXX
    if [[ "$URL" =~ share\.icloud\.com/photos/([A-Za-z0-9_+/=-]+) ]]; then
        local photo_id="${BASH_REMATCH[1]}"
        URL="https://www.icloud.com/photos/#${photo_id}"
        log_debug "Normalized URL: share -> www format"
    fi
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    parse_args "$@"

    # Check for updates (opt-in, runs in background conceptually but blocks minimally)
    check_for_updates

    # Try to use gum for beautiful output (non-blocking)
    check_gum || true

    # Print styled banner
    print_banner

    if [[ "$DEBUG_MODE" == "true" ]]; then
        log_warn "Debug mode enabled"
    fi

    if [[ "$ALL_MODE" == "true" ]]; then
        log_info "Album mode: downloading all photos"
    fi

    log_step "Checking dependencies..."
    ensure_node
    ensure_playwright

    local script_path
    script_path=$(create_extractor_script)

    if [[ "$ALL_MODE" == "true" ]]; then
        log_step "Extracting album from iCloud..."
    else
        log_step "Extracting image from iCloud..."
    fi

    log_debug "URL: $URL"
    log_debug "Output: $OUTPUT_DIR"
    log_debug "Quality: $QUALITY"
    log_debug "Timeout: ${TIMEOUT}s"
    log_debug "JSON output: $JSON_OUTPUT"
    log_debug "All mode: $ALL_MODE"

    cd "$GIIL_HOME"
    node "$script_path" "$URL" "$OUTPUT_DIR" "$QUALITY" "$BASE64_OUTPUT" "$DEBUG_MODE" "$TIMEOUT" "$JSON_OUTPUT" "$ALL_MODE"
}

main "$@"
