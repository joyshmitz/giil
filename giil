#!/usr/bin/env bash
#
# giil - Get iCloud Image Link
# Downloads images from iCloud photo shares using Playwright/Chromium
#
# Usage:
#   giil <icloud-photo-url> [options]
#
# Options:
#   --base64    Output image as base64 text instead of saving file
#   --output    Specify output directory (default: current directory)
#   --quality   JPEG quality 1-100 (default: 85)
#   --help      Show this help message
#
# Examples:
#   giil "https://www.icloud.com/photos/#02cD9okNHvVd-uuDnPCH3ZEEA"
#   giil "https://share.icloud.com/photos/02cD9okNHvVd-uuDnPCH3ZEEA" --base64
#   giil "https://share.icloud.com/photos/xxx" --output ~/Downloads --quality 75
#

set -euo pipefail

VERSION="1.0.0"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default values
BASE64_OUTPUT=false
OUTPUT_DIR="."
QUALITY=85
URL=""

# -----------------------------------------------------------------------------
# Helper functions
# -----------------------------------------------------------------------------

log_info() {
    echo -e "${GREEN}[giil]${NC} $1" >&2
}

log_warn() {
    echo -e "${YELLOW}[giil]${NC} $1" >&2
}

log_error() {
    echo -e "${RED}[giil]${NC} $1" >&2
}

log_step() {
    echo -e "${BLUE}[giil]${NC} $1" >&2
}

show_help() {
    cat << 'EOF'
giil - Get iCloud Image Link
Downloads images from iCloud photo shares using Playwright/Chromium

Usage:
  giil <icloud-photo-url> [options]

Options:
  --base64       Output image as base64 text instead of saving file
  --output DIR   Specify output directory (default: current directory)
  --quality N    JPEG quality 1-100 (default: 85)
  --version      Show version information
  --help         Show this help message

Examples:
  giil "https://www.icloud.com/photos/#02cD9okNHvVd-uuDnPCH3ZEEA"
  giil "https://share.icloud.com/photos/02cD9okNHvVd-uuDnPCH3ZEEA" --base64
  giil "https://share.icloud.com/photos/xxx" --output ~/Downloads --quality 75

Supported URL formats:
  - https://share.icloud.com/photos/<id>
  - https://www.icloud.com/photos/#<id>

Output:
  - By default: saves compressed JPEG with datetime filename
  - With --base64: outputs base64-encoded image to stdout

Dependencies (auto-installed on first run):
  - Node.js (v18+)
  - Playwright with Chromium
  - Sharp (image processing)

EOF
    exit 0
}

show_version() {
    echo "giil version ${VERSION}"
    exit 0
}

detect_os() {
    case "$(uname -s)" in
        Darwin*) echo "macos" ;;
        Linux*)  echo "linux" ;;
        *)       echo "unknown" ;;
    esac
}

# -----------------------------------------------------------------------------
# Dependency installation
# -----------------------------------------------------------------------------

install_node_macos() {
    if command -v brew &> /dev/null; then
        log_info "Installing Node.js via Homebrew..."
        brew install node
    else
        log_error "Homebrew not found. Please install Node.js manually:"
        log_error "  https://nodejs.org/ or 'brew install node'"
        exit 1
    fi
}

install_node_linux() {
    if command -v apt-get &> /dev/null; then
        log_info "Installing Node.js via apt..."
        sudo apt-get update
        sudo apt-get install -y nodejs npm
    elif command -v dnf &> /dev/null; then
        log_info "Installing Node.js via dnf..."
        sudo dnf install -y nodejs npm
    elif command -v yum &> /dev/null; then
        log_info "Installing Node.js via yum..."
        sudo yum install -y nodejs npm
    elif command -v pacman &> /dev/null; then
        log_info "Installing Node.js via pacman..."
        sudo pacman -S --noconfirm nodejs npm
    else
        log_error "Could not detect package manager. Please install Node.js manually:"
        log_error "  https://nodejs.org/"
        exit 1
    fi
}

ensure_node() {
    if ! command -v node &> /dev/null; then
        log_warn "Node.js not found. Installing..."
        local os=$(detect_os)
        case "$os" in
            macos) install_node_macos ;;
            linux) install_node_linux ;;
            *)
                log_error "Unsupported OS. Please install Node.js manually."
                exit 1
                ;;
        esac
    fi

    # Verify node version is sufficient
    local node_version=$(node --version | sed 's/v//' | cut -d. -f1)
    if [[ "$node_version" -lt 18 ]]; then
        log_warn "Node.js v18+ recommended. Current: $(node --version)"
    fi

    log_step "Node.js $(node --version)"
}

ensure_playwright() {
    local giil_dir="${HOME}/.giil"
    local package_json="${giil_dir}/package.json"
    local lock_file="${giil_dir}/.installed"

    # Create giil directory if it doesn't exist
    mkdir -p "$giil_dir"

    # Check if playwright is installed (using a marker file for speed)
    if [[ ! -f "$lock_file" ]] || [[ ! -d "${giil_dir}/node_modules/playwright" ]]; then
        log_info "Setting up Playwright (one-time installation)..."

        # Create package.json
        cat > "$package_json" << 'PACKAGE_EOF'
{
  "name": "giil-runtime",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "dependencies": {
    "playwright": "^1.40.0",
    "sharp": "^0.33.0"
  }
}
PACKAGE_EOF

        # Install dependencies
        cd "$giil_dir"
        log_step "Installing npm packages..."
        npm install --silent 2>/dev/null || npm install

        # Install Chromium browser
        log_step "Installing Chromium browser..."
        npx playwright install chromium 2>&1 | grep -v "^$" || true

        # Create marker file
        touch "$lock_file"

        log_info "Playwright setup complete!"
    fi
}

# -----------------------------------------------------------------------------
# Main extraction script (Node.js)
# -----------------------------------------------------------------------------

create_extractor_script() {
    local giil_dir="${HOME}/.giil"
    local script_path="${giil_dir}/extractor.mjs"

    cat > "$script_path" << 'SCRIPT_EOF'
import { chromium } from 'playwright';
import sharp from 'sharp';
import { writeFileSync } from 'fs';
import { join } from 'path';

const args = process.argv.slice(2);
const url = args[0];
const outputDir = args[1] || '.';
const quality = parseInt(args[2] || '85', 10);
const base64Output = args[3] === 'true';

if (!url) {
    console.error('Usage: node extractor.mjs <url> [outputDir] [quality] [base64]');
    process.exit(1);
}

async function extractImage() {
    const browser = await chromium.launch({
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage']
    });

    const context = await browser.newContext({
        viewport: { width: 1920, height: 1080 },
        userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
    });

    const page = await context.newPage();

    // Track image requests to capture the actual photo URL
    let photoBuffer = null;
    let photoContentType = null;

    page.on('response', async (response) => {
        const respUrl = response.url();
        const contentType = response.headers()['content-type'] || '';

        // Look for the actual photo being loaded (iCloud uses specific CDN patterns)
        if ((respUrl.includes('cvws.icloud-content.com') ||
             respUrl.includes('.icloud.com') && contentType.startsWith('image/')) &&
            (contentType.includes('image/jpeg') ||
             contentType.includes('image/png') ||
             contentType.includes('image/heic') ||
             contentType.includes('image/heif') ||
             contentType.includes('image/webp'))) {
            try {
                const buffer = await response.body();
                // Keep the largest image (the actual photo, not thumbnails)
                if (!photoBuffer || buffer.length > photoBuffer.length) {
                    photoBuffer = buffer;
                    photoContentType = contentType;
                }
            } catch (e) {
                // Response body might not be available
            }
        }
    });

    try {
        // Navigate to the iCloud photo page
        console.error(`[giil] Loading: ${url}`);
        await page.goto(url, {
            waitUntil: 'networkidle',
            timeout: 60000
        });

        // Wait for the photo to load
        console.error('[giil] Waiting for photo to load...');

        // Try multiple selectors for iCloud photo viewer
        const selectors = [
            'img[src*="cvws.icloud-content"]',
            'img[src*="icloud-content"]',
            '.photo-viewer img',
            '.media-viewer img',
            '[data-testid="photo"] img',
            'img.photo',
            'main img',
            'img[alt]'
        ];

        let imgElement = null;
        for (const selector of selectors) {
            try {
                imgElement = await page.waitForSelector(selector, { timeout: 5000 });
                if (imgElement) {
                    console.error(`[giil] Found image element`);
                    break;
                }
            } catch (e) {
                // Try next selector
            }
        }

        // Additional wait for image to fully load
        await page.waitForTimeout(3000);

        // If we captured an image from network requests, use that
        if (photoBuffer && photoBuffer.length > 10000) {
            console.error(`[giil] Captured image from network (${(photoBuffer.length / 1024).toFixed(1)} KB)`);
        } else if (imgElement) {
            // Fallback: screenshot the image element
            console.error('[giil] Taking screenshot of image element...');
            photoBuffer = await imgElement.screenshot({ type: 'png' });
        } else {
            // Last resort: screenshot the viewport
            console.error('[giil] Taking viewport screenshot...');
            photoBuffer = await page.screenshot({
                type: 'png',
                fullPage: false
            });
        }

        if (!photoBuffer || photoBuffer.length < 1000) {
            throw new Error('Failed to capture image - buffer too small');
        }

        // Process with sharp - compress to JPEG
        console.error('[giil] Processing image...');
        const metadata = await sharp(photoBuffer).metadata();
        console.error(`[giil] Original: ${metadata.width}x${metadata.height}, ${metadata.format}`);

        const processedBuffer = await sharp(photoBuffer)
            .jpeg({
                quality: quality,
                mozjpeg: true
            })
            .toBuffer();

        // Generate filename with datetime
        const now = new Date();
        const dateStr = now.toISOString()
            .replace(/[:.]/g, '-')
            .replace('T', '_')
            .replace('Z', '');
        const filename = `icloud_photo_${dateStr}.jpg`;

        if (base64Output) {
            // Output as base64
            console.log(processedBuffer.toString('base64'));
            console.error(`[giil] Output: base64 (${(processedBuffer.length / 1024).toFixed(1)} KB)`);
        } else {
            // Save to file
            const outputPath = join(outputDir, filename);
            writeFileSync(outputPath, processedBuffer);
            console.log(outputPath);
            console.error(`[giil] Saved: ${outputPath}`);
            console.error(`[giil] Size: ${(processedBuffer.length / 1024).toFixed(1)} KB (quality: ${quality})`);
        }

    } catch (error) {
        console.error(`[giil] Error: ${error.message}`);

        // Debug: take a screenshot to see what's on the page
        try {
            const debugPath = join(outputDir, 'giil_debug_screenshot.png');
            await page.screenshot({ path: debugPath, fullPage: true });
            console.error(`[giil] Debug screenshot: ${debugPath}`);
        } catch (e) {
            // Ignore debug errors
        }

        process.exit(1);
    } finally {
        await browser.close();
    }
}

extractImage().catch(err => {
    console.error(`[giil] Fatal: ${err.message}`);
    process.exit(1);
});
SCRIPT_EOF

    echo "$script_path"
}

# -----------------------------------------------------------------------------
# Argument parsing
# -----------------------------------------------------------------------------

parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --base64)
                BASE64_OUTPUT=true
                shift
                ;;
            --output)
                OUTPUT_DIR="$2"
                shift 2
                ;;
            --quality)
                QUALITY="$2"
                shift 2
                ;;
            --version|-v)
                show_version
                ;;
            --help|-h)
                show_help
                ;;
            -*)
                log_error "Unknown option: $1"
                log_error "Run 'giil --help' for usage"
                exit 1
                ;;
            *)
                if [[ -z "$URL" ]]; then
                    URL="$1"
                else
                    log_error "Multiple URLs not supported"
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$URL" ]]; then
        log_error "No URL provided"
        log_error "Run 'giil --help' for usage"
        exit 1
    fi

    # Validate quality
    if ! [[ "$QUALITY" =~ ^[0-9]+$ ]] || [[ "$QUALITY" -lt 1 ]] || [[ "$QUALITY" -gt 100 ]]; then
        log_error "Quality must be between 1 and 100"
        exit 1
    fi

    # Create output directory if it doesn't exist
    if [[ ! -d "$OUTPUT_DIR" ]]; then
        mkdir -p "$OUTPUT_DIR"
    fi

    # Normalize URL (handle share.icloud.com redirects)
    if [[ "$URL" == *"share.icloud.com"* ]]; then
        # Extract the photo ID and convert to www.icloud.com format
        local photo_id=$(echo "$URL" | grep -oE '[A-Za-z0-9_-]{20,}' | tail -1)
        if [[ -n "$photo_id" ]]; then
            URL="https://www.icloud.com/photos/#${photo_id}"
            log_step "Normalized URL"
        fi
    fi
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    parse_args "$@"

    log_info "giil v${VERSION}"
    log_step "Checking dependencies..."
    ensure_node
    ensure_playwright

    local script_path=$(create_extractor_script)
    local giil_dir="${HOME}/.giil"

    log_step "Extracting image from iCloud..."

    cd "$giil_dir"
    node "$script_path" "$URL" "$OUTPUT_DIR" "$QUALITY" "$BASE64_OUTPUT"
}

main "$@"
